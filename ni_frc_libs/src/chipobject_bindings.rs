/* automatically generated by rust-bindgen 0.65.1 */

pub const NiFpga_Linux: u32 = 1;
pub const NiFpga_Gcc: u32 = 1;
pub const NiFpga_C89: u32 = 1;
pub const NiFpga_C90: u32 = 1;
pub const NiFpga_C94: u32 = 1;
pub const NiFpga_C99: u32 = 1;
pub const NiFpga_C11: u32 = 1;
#[doc = " A boolean value; either NiFpga_False or NiFpga_True."]
pub type NiFpga_Bool = u8;
#[doc = " Represents a false condition."]
pub const NiFpga_False: NiFpga_Bool = 0;
#[doc = " Represents a true condition."]
pub const NiFpga_True: NiFpga_Bool = 1;
#[doc = " Represents the resulting status of a function call through its return value.\n 0 is success, negative values are errors, and positive values are warnings."]
pub type NiFpga_Status = i32;
#[doc = " No errors or warnings."]
pub const NiFpga_Status_Success: NiFpga_Status = 0;
#[doc = " The timeout expired before the FIFO operation could complete."]
pub const NiFpga_Status_FifoTimeout: NiFpga_Status = -50400;
#[doc = " No transfer is in progress because the transfer was aborted by the client.\n The operation could not be completed as specified."]
pub const NiFpga_Status_TransferAborted: NiFpga_Status = -50405;
#[doc = " A memory allocation failed. Try again after rebooting."]
pub const NiFpga_Status_MemoryFull: NiFpga_Status = -52000;
#[doc = " An unexpected software error occurred."]
pub const NiFpga_Status_SoftwareFault: NiFpga_Status = -52003;
#[doc = " A parameter to a function was not valid. This could be a NULL pointer, a bad\n value, etc."]
pub const NiFpga_Status_InvalidParameter: NiFpga_Status = -52005;
#[doc = " A required resource was not found. The NiFpga.* library, the RIO resource, or\n some other resource may be missing."]
pub const NiFpga_Status_ResourceNotFound: NiFpga_Status = -52006;
#[doc = " A required resource was not properly initialized. This could occur if\n NiFpga_Initialize was not called or a required NiFpga_IrqContext was not\n reserved."]
pub const NiFpga_Status_ResourceNotInitialized: NiFpga_Status = -52010;
#[doc = " The FPGA is already running."]
pub const NiFpga_Status_FpgaAlreadyRunning: NiFpga_Status = -61003;
#[doc = " An error occurred downloading the VI to the FPGA device. Verify that\n the target is connected and powered and that the resource of the target\n is properly configured."]
pub const NiFpga_Status_DownloadError: NiFpga_Status = -61018;
#[doc = " The bitfile was not compiled for the specified resource's device type."]
pub const NiFpga_Status_DeviceTypeMismatch: NiFpga_Status = -61024;
#[doc = " An error was detected in the communication between the host computer and the\n FPGA target."]
pub const NiFpga_Status_CommunicationTimeout: NiFpga_Status = -61046;
#[doc = " The timeout expired before any of the IRQs were asserted."]
pub const NiFpga_Status_IrqTimeout: NiFpga_Status = -61060;
#[doc = " The specified bitfile is invalid or corrupt."]
pub const NiFpga_Status_CorruptBitfile: NiFpga_Status = -61070;
#[doc = " The requested FIFO depth is invalid. It is either 0 or an amount not\n supported by the hardware."]
pub const NiFpga_Status_BadDepth: NiFpga_Status = -61072;
#[doc = " The number of FIFO elements is invalid. Either the number is greater than the\n depth of the host memory DMA FIFO, or more elements were requested for\n release than had been acquired."]
pub const NiFpga_Status_BadReadWriteCount: NiFpga_Status = -61073;
#[doc = " A hardware clocking error occurred. A derived clock lost lock with its base\n clock during the execution of the LabVIEW FPGA VI. If any base clocks with\n derived clocks are referencing an external source, make sure that the\n external source is connected and within the supported frequency, jitter,\n accuracy, duty cycle, and voltage specifications. Also verify that the\n characteristics of the base clock match the configuration specified in the\n FPGA Base Clock Properties. If all base clocks with derived clocks are\n generated from free-running, on-board sources, please contact National\n Instruments technical support at ni.com/support."]
pub const NiFpga_Status_ClockLostLock: NiFpga_Status = -61083;
#[doc = " The operation could not be performed because the FPGA is busy. Stop all\n activities on the FPGA before requesting this operation. If the target is in\n Scan Interface programming mode, put it in FPGA Interface programming mode."]
pub const NiFpga_Status_FpgaBusy: NiFpga_Status = -61141;
#[doc = " The operation could not be performed because the FPGA is busy operating in\n FPGA Interface C API mode. Stop all activities on the FPGA before requesting\n this operation."]
pub const NiFpga_Status_FpgaBusyFpgaInterfaceCApi: NiFpga_Status = -61200;
#[doc = " The chassis is in Scan Interface programming mode. In order to run FPGA VIs,\n you must go to the chassis properties page, select FPGA programming mode, and\n deploy settings."]
pub const NiFpga_Status_FpgaBusyScanInterface: NiFpga_Status = -61201;
#[doc = " The operation could not be performed because the FPGA is busy operating in\n FPGA Interface mode. Stop all activities on the FPGA before requesting this\n operation."]
pub const NiFpga_Status_FpgaBusyFpgaInterface: NiFpga_Status = -61202;
#[doc = " The operation could not be performed because the FPGA is busy operating in\n Interactive mode. Stop all activities on the FPGA before requesting this\n operation."]
pub const NiFpga_Status_FpgaBusyInteractive: NiFpga_Status = -61203;
#[doc = " The operation could not be performed because the FPGA is busy operating in\n Emulation mode. Stop all activities on the FPGA before requesting this\n operation."]
pub const NiFpga_Status_FpgaBusyEmulation: NiFpga_Status = -61204;
#[doc = " LabVIEW FPGA does not support the Reset method for bitfiles that allow\n removal of implicit enable signals in single-cycle Timed Loops."]
pub const NiFpga_Status_ResetCalledWithImplicitEnableRemoval: NiFpga_Status = -61211;
#[doc = " LabVIEW FPGA does not support the Abort method for bitfiles that allow\n removal of implicit enable signals in single-cycle Timed Loops."]
pub const NiFpga_Status_AbortCalledWithImplicitEnableRemoval: NiFpga_Status = -61212;
#[doc = " LabVIEW FPGA does not support Close and Reset if Last Reference for bitfiles\n that allow removal of implicit enable signals in single-cycle Timed Loops.\n Pass the NiFpga_CloseAttribute_NoResetIfLastSession attribute to NiFpga_Close\n instead of 0."]
pub const NiFpga_Status_CloseAndResetCalledWithImplicitEnableRemoval: NiFpga_Status = -61213;
#[doc = " For bitfiles that allow removal of implicit enable signals in single-cycle\n Timed Loops, LabVIEW FPGA does not support this method prior to running the\n bitfile."]
pub const NiFpga_Status_ImplicitEnableRemovalButNotYetRun: NiFpga_Status = -61214;
#[doc = " Bitfiles that allow removal of implicit enable signals in single-cycle Timed\n Loops can run only once. Download the bitfile again before re-running the VI."]
pub const NiFpga_Status_RunAfterStoppedCalledWithImplicitEnableRemoval: NiFpga_Status = -61215;
#[doc = " A gated clock has violated the handshaking protocol. If you are using\n external gated clocks, ensure that they follow the required clock gating\n protocol. If you are generating your clocks internally, please contact\n National Instruments Technical Support."]
pub const NiFpga_Status_GatedClockHandshakingViolation: NiFpga_Status = -61216;
#[doc = " The number of elements requested must be less than or equal to the number of\n unacquired elements left in the host memory DMA FIFO. There are currently\n fewer unacquired elements left in the FIFO than are being requested. Release\n some acquired elements before acquiring more elements."]
pub const NiFpga_Status_ElementsNotPermissibleToBeAcquired: NiFpga_Status = -61219;
#[doc = " The operation could not be performed because the FPGA is in configuration or\n discovery mode. Wait for configuration or discovery to complete and retry\n your operation."]
pub const NiFpga_Status_FpgaBusyConfiguration: NiFpga_Status = -61252;
#[doc = " LabVIEW FPGA does not support Close and Reset if Last Reference for bitfiles\n that do not support Reset. Pass the\n NiFpga_CloseAttribute_NoResetIfLastSession attribute to NiFpga_Close instead\n of 0."]
pub const NiFpga_Status_CloseAndResetCalledWithResetNotSupported: NiFpga_Status = -61253;
#[doc = " An unexpected internal error occurred."]
pub const NiFpga_Status_InternalError: NiFpga_Status = -61499;
#[doc = " DMA from host to FPGA target is not supported for this remote system. Use\n another method for I/O or change the controller associated with the FPGA\n target."]
pub const NiFpga_Status_DmaOutputNotSupported: NiFpga_Status = -63001;
#[doc = " The specified DMA FIFO depth is greater than the maximum size supported by\n this system."]
pub const NiFpga_Status_DmaFifoDepthNotSupported: NiFpga_Status = -63002;
#[doc = " The NI-RIO driver was unable to allocate memory for a FIFO. This can happen\n when the combined depth of all DMA FIFOs exceeds the maximum depth for the\n controller, or when the controller runs out of system memory. You may be able\n to reconfigure the controller with a greater maximum FIFO depth. For more\n information, refer to the NI KnowledgeBase article 65OF2ERQ."]
pub const NiFpga_Status_TotalDmaFifoDepthExceeded: NiFpga_Status = -63003;
#[doc = " Operation failed due to device reconfiguration. Multiple sessions to FPGA\n devices are not supported. Close the other session and retry this operation."]
pub const NiFpga_Status_DeviceReconfigured: NiFpga_Status = -63030;
#[doc = " The operation could not be completed because another session is accessing the\n device. Close all other sessions and retry."]
pub const NiFpga_Status_DeviceInvariant: NiFpga_Status = -63031;
#[doc = " Access to the remote system was denied. If you are trying to connect to an RT\n target, use MAX to check the Remote Device Access settings under\n Software>>[Recommended software set, such as \"NI CompactRIO version -\n date\"]>>NI-RIO>>NI-RIO Settings on the remote system. If you are trying to\n connect to a desktop Linux target, check the settings in\n /etc/natinst/nirio/nirio.ini on the Linux target."]
pub const NiFpga_Status_AccessDenied: NiFpga_Status = -63033;
#[doc = " The attempt to open a RIO session failed because the driver was not yet\n initialized."]
pub const NiFpga_Status_DriverNotInitialized: NiFpga_Status = -63035;
#[doc = " The operation could not be completed because the device being accessed was\n unavailable, either because it was disconnected from the network or because\n power was removed (e.g., the system went into a low-power state). Close any\n RIO FPGA sessions; check network, USB, and power connections; power-cycle the\n device if necessary; and open a new RIO session."]
pub const NiFpga_Status_ResourceRemoved: NiFpga_Status = -63036;
#[doc = " The NI-RIO software on the host is not compatible with the software on the\n target. Upgrade the NI-RIO software on the host in order to connect to this\n target."]
pub const NiFpga_Status_HostVersionMismatch: NiFpga_Status = -63038;
#[doc = " A connection could not be established to the specified remote device. Ensure\n that the device is on and accessible over the network, that the device is not\n in safe mode, that NI-RIO software is installed, and that the RIO server is\n running and properly configured.  Refer to Software>>NI-RIO>>NI-RIO Settings\n under the system in MAX."]
pub const NiFpga_Status_RpcConnectionError: NiFpga_Status = -63040;
#[doc = " The connection to the remote device has been lost due to an error on the\n remote device. Retry the operation. If the remote device continues to report\n this error, check its power supply and look for diagnostic messages on the\n console."]
pub const NiFpga_Status_RpcServerError: NiFpga_Status = -63041;
#[doc = " A fault on the network caused the operation to fail."]
pub const NiFpga_Status_NetworkFault: NiFpga_Status = -63042;
#[doc = " The session is invalid. The target may have been reset or rebooted, or the\n network connection may have timed out because of processor overuse. Check the\n network connection, reduce the demand on the processor, and decrease the\n timeout of the operation that failed. If the problem persists, visit\n ni.com/info and enter the Info Code expd6p."]
pub const NiFpga_Status_RpcSessionError: NiFpga_Status = -63043;
#[doc = " The RIO server could not be found on the specified remote device. Ensure that\n NI-RIO software is installed and that the RIO server is running and properly\n configured.  Refer to Software>>NI-RIO>>NI-RIO Settings under the system in\n MAX."]
pub const NiFpga_Status_RpcServerMissing: NiFpga_Status = -63044;
#[doc = " The requested feature is not supported when using a remote RIO session.\n Opening a remote RIO session occurs when the resource string is specified as\n rio://hostname/device_name.  A local session can be opened by specifying just\n the device_name."]
pub const NiFpga_Status_FeatureNotSupportedOverRpc: NiFpga_Status = -63045;
#[doc = " The specified trigger line is already reserved. Consult the MAX Trigger\n settings or the trigger reservations for each device within the system."]
pub const NiFpga_Status_TriggerReserved: NiFpga_Status = -63050;
#[doc = " The specified trigger line is not reserved in the current session."]
pub const NiFpga_Status_TriggerNotReserved: NiFpga_Status = -63051;
#[doc = " Trigger lines are not supported or enabled. For PXI, identify the controller\n and chassis using MAX."]
pub const NiFpga_Status_TriggerNotSupported: NiFpga_Status = -63052;
#[doc = " The specified event type is invalid."]
pub const NiFpga_Status_EventInvalid: NiFpga_Status = -63070;
#[doc = " The specified RIO event has already been enabled for this session."]
pub const NiFpga_Status_EventEnabled: NiFpga_Status = -63071;
#[doc = " The specified RIO event has not been enabled for this session. Attempting a\n Wait on IRQ after an Abort causes this error."]
pub const NiFpga_Status_EventNotEnabled: NiFpga_Status = -63072;
#[doc = " The specified event did not occur within the specified time period, in\n milliseconds. Extend the time period, or ignore if the result was expected."]
pub const NiFpga_Status_EventTimedOut: NiFpga_Status = -63073;
#[doc = " The allocated buffer is too small."]
pub const NiFpga_Status_BufferInvalidSize: NiFpga_Status = -63080;
#[doc = " The caller did not allocate a memory buffer."]
pub const NiFpga_Status_BufferNotAllocated: NiFpga_Status = -63081;
#[doc = " The operation could not complete because another session is accessing the\n FIFO. Close the other session and retry."]
pub const NiFpga_Status_FifoReserved: NiFpga_Status = -63082;
#[doc = " A Configure FIFO, Stop FIFO, Read FIFO, or Write FIFO function was called\n while the host had acquired elements of the FIFO. Release all acquired\n elements before configuring, stopping, reading, or writing."]
pub const NiFpga_Status_FifoElementsCurrentlyAcquired: NiFpga_Status = -63083;
#[doc = " A function was called using a misaligned address. The address must be a\n multiple of the size of the datatype."]
pub const NiFpga_Status_MisalignedAccess: NiFpga_Status = -63084;
#[doc = " The FPGA Read/Write Control Function is accessing a control or indicator with\n data that exceeds the maximum size supported on the current target. Refer to\n the hardware documentation for the limitations on data types for this target."]
pub const NiFpga_Status_ControlOrIndicatorTooLarge: NiFpga_Status = -63085;
#[doc = " The FIFO function called cannot be used while the FIFO is running. To use\n this function, ensure the FIFO is stopped."]
pub const NiFpga_Status_OperationNotSupportedWhileStarted: NiFpga_Status = -63086;
#[doc = " The function called does not match the datatype of the specified property.\n Ensure you are calling the correct function for the property."]
pub const NiFpga_Status_TypesDoNotMatch: NiFpga_Status = -63087;
#[doc = " Cannot acquire more regions from the selected FIFO. Release some regions and\n try again."]
pub const NiFpga_Status_OutOfFifoRegions: NiFpga_Status = -63088;
#[doc = " A valid .lvbitx bitfile is required. If you are using a vaild .lvbitx\n bitfile, the bitfile may not be compatible with the software you are using.\n Determine which version of LabVIEW was used to make the bitfile, update your\n software to that version or later, and try again."]
pub const NiFpga_Status_BitfileReadError: NiFpga_Status = -63101;
#[doc = " Invalid output directory."]
pub const NiFpga_Status_InvalidOutputDirectory: NiFpga_Status = -63102;
#[doc = " Invalid prefix override. Prefixes must include only alphanumerics and\n underscores."]
pub const NiFpga_Status_InvalidPrefixOverride: NiFpga_Status = -63103;
#[doc = " Could not convert \"%s\" to a valid C/C++ identifier."]
pub const NiFpga_Status_NoSuitableIdentifier: NiFpga_Status = -63104;
#[doc = " The C/C++ identifier \"%s\" is already in use and could not be created."]
pub const NiFpga_Status_IdentifierConflict: NiFpga_Status = -63105;
#[doc = " The specified bitfile is not the bitfile used to generate the C API. Specify\n the original bitfile or regenerate the C API for this bitfile."]
pub const NiFpga_Status_SignatureMismatch: NiFpga_Status = -63106;
#[doc = " The bitfile you are trying to use is incompatible with the version of NI-RIO\n installed on the target and/or host. Update the version of NI-RIO on the\n target and/or host to the same version (or later) used to compile the\n bitfile. Alternatively, recompile the bitfile with the same version of NI-RIO\n that is currently installed on the target and/or host."]
pub const NiFpga_Status_IncompatibleBitfile: NiFpga_Status = -63107;
#[doc = " An unspecified hardware failure has occurred. The operation could not be\n completed."]
pub const NiFpga_Status_HardwareFault: NiFpga_Status = -63150;
#[doc = " You must download the bitfile to the flash memory on the FPGA device before\n you can set when the bitfile is autoloaded. Download the bitfile to the flash\n memory then try again."]
pub const NiFpga_Status_NoBitfilePresentOnFlash: NiFpga_Status = -63160;
#[doc = " The device has shut down to protect against excessive power consumption.\n Check airflow and cooling and reboot the system. To avoid this error, monitor\n the power consumption, power shutdown threshold, and margin of the device. If\n necessary, reduce FPGA power consumption."]
pub const NiFpga_Status_PowerShutdown: NiFpga_Status = -63170;
#[doc = " The device has shut down to protect against excessive FPGA temperature. Check\n airflow and cooling and reboot the system. To avoid this error, monitor the\n FPGA temperature, temperature shutdown threshold, and margin of the FPGA. If\n necessary, reduce FPGA temperature."]
pub const NiFpga_Status_ThermalShutdown: NiFpga_Status = -63171;
#[doc = " The alias name is invalid. A valid alias name must meet the following\n conditions:  1) Cannot be or contain a reserved word. 2) Can use only\n alphanumeric characters, hyphens, and underscores. 3) Cannot conflict with\n the default alias of another device. A default alias is the name that the NI-\n RIO Device Driver assigns to a device based on its attributes if you have not\n assigned a custom alias to the device using MAX or the System Configuration\n API. For example, 'PXI1Slot3' is the default alias for the device at Slot 3\n of PXI Chassis 1, and it cannot be used as an alias name for any other\n device. Refer to the LabVIEW Help for NI-RIO for more information about\n aliases."]
pub const NiFpga_Status_InvalidAliasName: NiFpga_Status = -63180;
#[doc = " The supplied alias was not found."]
pub const NiFpga_Status_AliasNotFound: NiFpga_Status = -63181;
#[doc = " An invalid device access setting was specified. RIO device access patterns\n may contain only alphanumerics, '-', '_', '.', and '*'."]
pub const NiFpga_Status_InvalidDeviceAccess: NiFpga_Status = -63182;
#[doc = " An invalid port was specified. The RIO server port must be between 0 and\n 65535, where 0 indicates a dynamically assigned port. Port 3580 is reserved\n and cannot be used."]
pub const NiFpga_Status_InvalidPort: NiFpga_Status = -63183;
#[doc = " The selected bitfile requires a driver that could not be loaded or that was\n invalid. Use MAX to install all necessary software to your target. Note that\n if your project includes modules under the chassis item, user-defined\n variables, or references to the Scan Clock Chassis I/O item, you must install\n NI-RIO IO Scan software to the target."]
pub const NiFpga_Status_ChildDeviceNotInserted: NiFpga_Status = -63184;
#[doc = " This remote system does not support connections to other remote systems."]
pub const NiFpga_Status_RemoteTarget: NiFpga_Status = -63187;
#[doc = " The operation is no longer supported."]
pub const NiFpga_Status_DeprecatedFunction: NiFpga_Status = -63188;
#[doc = " The supplied search pattern is invalid."]
pub const NiFpga_Status_InvalidPattern: NiFpga_Status = -63189;
#[doc = " The specified device was not found. Use MAX or System Designer to find the\n proper resource name for the intended device."]
pub const NiFpga_Status_InvalidResourceName: NiFpga_Status = -63192;
#[doc = " The requested feature is not supported."]
pub const NiFpga_Status_FeatureNotSupported: NiFpga_Status = -63193;
#[doc = " The NI-RIO software on the target system is not compatible with this\n software. Upgrade the NI-RIO software on the target system."]
pub const NiFpga_Status_VersionMismatch: NiFpga_Status = -63194;
#[doc = " The handle for device communication is invalid or has been closed. Restart\n the application."]
pub const NiFpga_Status_InvalidSession: NiFpga_Status = -63195;
#[doc = " An invalid attribute has been specified."]
pub const NiFpga_Status_InvalidAttribute: NiFpga_Status = -63196;
#[doc = " An invalid attribute value has been specified."]
pub const NiFpga_Status_InvalidAttributeValue: NiFpga_Status = -63197;
#[doc = " The system has run out of resources. Close a session and retry the operation."]
pub const NiFpga_Status_OutOfHandles: NiFpga_Status = -63198;
#[doc = " The session could not be opened because another session with a different\n bitfile is already open on the device. Close the current session before\n opening another."]
pub const NiFpga_Status_CannotDownloadDifferentBitfile: NiFpga_Status = -63199;
#[doc = " This struct contains information needed to interpret an FXP Type.\n   - `isSigned` tells if the type is signed.\n   - `wordLength` tells us the number of bits used in the type.\n   - `integerWordLength` is the number of bits to shift the binary point to\n     reach the most significant bit.\n\n More information can be found at the following links:\n - http://zone.ni.com/reference/en-XX/help/371361J-01/lvconcepts/numeric_data/\n - http://www.ni.com/newsletter/50303/en/\n - http://digital.ni.com/public.nsf/allkb/346CC529EC1092B3862574FA0053B9B2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiFpga_FxpTypeInfo {
    pub isSigned: NiFpga_Bool,
    pub wordLength: u8,
    pub integerWordLength: i16,
}
#[test]
fn bindgen_test_layout_NiFpga_FxpTypeInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NiFpga_FxpTypeInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NiFpga_FxpTypeInfo>(),
        4usize,
        concat!("Size of: ", stringify!(NiFpga_FxpTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NiFpga_FxpTypeInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(NiFpga_FxpTypeInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isSigned) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiFpga_FxpTypeInfo),
            "::",
            stringify!(isSigned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wordLength) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(NiFpga_FxpTypeInfo),
            "::",
            stringify!(wordLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integerWordLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(NiFpga_FxpTypeInfo),
            "::",
            stringify!(integerWordLength)
        )
    );
}
extern "C" {
    #[doc = " You must call this function before all other function calls. This function\n loads the NiFpga library so that all the other functions will work. If this\n function succeeds, you must call NiFpga_Finalize after all other function\n calls.\n\n @warning This function is not thread safe.\n\n @return result of the call"]
    pub fn NiFpga_Initialize() -> NiFpga_Status;
}
extern "C" {
    #[doc = " You must call this function after all other function calls if\n NiFpga_Initialize succeeds. This function unloads the NiFpga library.\n\n @warning This function is not thread safe.\n\n @return result of the call"]
    pub fn NiFpga_Finalize() -> NiFpga_Status;
}
#[doc = " A handle to an FPGA session."]
pub type NiFpga_Session = u32;
#[doc = " By default the FPGA VI will start running when Open is called.\n This attribute will ensure the bitfile is loaded to the FPGA, but does not\n run the VI.  If the VI is already running on the FPGA, its state will not\n be changed."]
pub const NiFpga_OpenAttribute_NiFpga_OpenAttribute_NoRun: NiFpga_OpenAttribute = 1;
#[doc = " On windows the bitfile path is assumed to be encoded as the current\n codepage. This attribute will specify that the bitfile path is encoded as\n UTF-8. This parameter has no effect on Linux systems."]
pub const NiFpga_OpenAttribute_NiFpga_OpenAttribute_BitfilePathIsUTF8: NiFpga_OpenAttribute = 2;
#[doc = " Causes the  bitfile argument passed in to be interpreted as the contents\n of the lvbitx file rather than a path to an lvbitx file."]
pub const NiFpga_OpenAttribute_NiFpga_OpenAttribute_BitfileContentsNotPath: NiFpga_OpenAttribute =
    1073741824;
#[doc = " Skips the check of the signature argument, which otherwise would ensure\n that users would not accidentally rebuild their bitfile (thereby getting\n new offsets, etc.) without also regenerating their C API and rebuilding\n their application with the new constants. This is useful if one is not\n using the FPGA Interface C API Generator to obtain resource information,\n such as by calling NiFpga_FindRegister or NiFpga_FindFifo.\n If using this attribute, pass `NULL` to `signature` instead."]
pub const NiFpga_OpenAttribute_NiFpga_OpenAttribute_IgnoreSignatureArgument: NiFpga_OpenAttribute =
    2147483648;
#[doc = " Attributes that NiFpga_Open accepts."]
pub type NiFpga_OpenAttribute = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Opens a session to the FPGA. This call ensures that the contents of the\n bitfile are programmed to the FPGA. The FPGA runs unless the\n NiFpga_OpenAttribute_NoRun attribute is used.\n\n Because different operating systems have different default current working\n directories for applications, you must pass an absolute path for the bitfile\n parameter. If you pass only the filename instead of an absolute path, the\n operating system may not be able to locate the bitfile. For example, the\n default current working directory is C:/ni-rt/system/ for Phar Lap ETS.s.\n Because the generated *_Bitfile constant is a \"#define\" to a\n string literal, you can use C/C++ string-literal concatenation to form an\n absolute path. For example, if the bitfile is in the root directory of a\n Phar Lap ETS system, pass the following for the bitfile parameter.\n\n    \\\"C:\\\\\\\\\\\\\\\\\\\" NiFpga_MyApplication_Bitfile\n\n @param bitfile path to the bitfile\n @param signature signature of the bitfile\n @param resource RIO resource string to open (\"RIO0\" or \"rio://mysystem/RIO\")\n @param attribute bitwise OR of any NiFpga_OpenAttributes, or 0\n @param session outputs the session handle, which must be closed when no\n                longer needed\n @return result of the call"]
    pub fn NiFpga_Open(
        bitfile: *const ::std::os::raw::c_char,
        signature: *const ::std::os::raw::c_char,
        resource: *const ::std::os::raw::c_char,
        attribute: u32,
        session: *mut NiFpga_Session,
    ) -> NiFpga_Status;
}
pub const NiFpga_CloseAttribute_NiFpga_CloseAttribute_NoResetIfLastSession: NiFpga_CloseAttribute =
    1;
#[doc = " Attributes that NiFpga_Close accepts."]
pub type NiFpga_CloseAttribute = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Closes the session to the FPGA. The FPGA resets unless either another session\n is still open or you use the NiFpga_CloseAttribute_NoResetIfLastSession\n attribute.\n\n @param session handle to a currently open session\n @param attribute bitwise OR of any NiFpga_CloseAttributes, or 0\n @return result of the call"]
    pub fn NiFpga_Close(session: NiFpga_Session, attribute: u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Returns the signature of the bitfile currently loaded on the FPGA. If the\n signature size specified is too small, signature size will be filled with\n the size required and NiFpga_Status_InvalidParameter will be returned.\n\n @param session handle to a currently open session\n @param signature the uint32_t array to fill with the signature value\n @param signatureSize the number of elements in signature\n @return result of the call"]
    pub fn NiFpga_GetBitfileSignature(
        session: NiFpga_Session,
        signature: *mut u32,
        signatureSize: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Returns the offset of a control or indicator.  This offset can be used as the\n control or indicator parameter to a Read/Write or Read/WriteArray call.\n This intent of this function is to make sharing code that accesses the same\n interface implemented in different bitfiles easy.\n\n @warning Its possible to create a FPGA VI with multiple controls and\n indicators that have the same name. Attempting to find a control or indicator\n that shares a name is undefined behavior.\n\n @warning You must ensure you use the correct Read/Write call with the correct\n type for the register you have looked up.\n\n @param session handle to a currently open session\n @param registerName the name of the register to find\n @param registerOffset outputs the offset of the register\n @return result of the call"]
    pub fn NiFpga_FindRegister(
        session: NiFpga_Session,
        registerName: *const ::std::os::raw::c_char,
        registerOffset: *mut u32,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Returns the fifoNumber of a FIFO.  This fifoNumber can be used as the\n fifo parameter to a Read/WriteFifo or AcquireFifoRead/WriteElements call.\n\n @param session handle to a currently open session\n @param fifoName the name of the FIFO to find\n @param fifoNumber outputs the number of the FIFO\n @return result of the call"]
    pub fn NiFpga_FindFifo(
        session: NiFpga_Session,
        fifoName: *const ::std::os::raw::c_char,
        fifoNumber: *mut u32,
    ) -> NiFpga_Status;
}
pub const NiFpga_RunAttribute_NiFpga_RunAttribute_WaitUntilDone: NiFpga_RunAttribute = 1;
#[doc = " Attributes that NiFpga_Run accepts."]
pub type NiFpga_RunAttribute = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Runs the FPGA VI on the target. If you use NiFpga_RunAttribute_WaitUntilDone,\n NiFpga_Run blocks the thread until the FPGA finishes running.\n\n @param session handle to a currently open session\n @param attribute bitwise OR of any NiFpga_RunAttributes, or 0\n @return result of the call"]
    pub fn NiFpga_Run(session: NiFpga_Session, attribute: u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Aborts the FPGA VI.\n\n @param session handle to a currently open session\n @return result of the call"]
    pub fn NiFpga_Abort(session: NiFpga_Session) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Resets the FPGA VI.\n\n @param session handle to a currently open session\n @return result of the call"]
    pub fn NiFpga_Reset(session: NiFpga_Session) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Re-downloads the FPGA bitstream to the target.\n\n @param session handle to a currently open session\n @return result of the call"]
    pub fn NiFpga_Download(session: NiFpga_Session) -> NiFpga_Status;
}
#[doc = " The FPGA VI has either been downloaded and not run, or the VI was aborted\n or reset."]
pub const NiFpga_FpgaViState_NiFpga_FpgaViState_NotRunning: NiFpga_FpgaViState = 0;
#[doc = " An error has occurred."]
pub const NiFpga_FpgaViState_NiFpga_FpgaViState_Invalid: NiFpga_FpgaViState = 1;
#[doc = " The FPGA VI is currently executing."]
pub const NiFpga_FpgaViState_NiFpga_FpgaViState_Running: NiFpga_FpgaViState = 2;
#[doc = " The FPGA VI stopped normally.  This indicates it was not aborted or reset,\n but instead reached the end of any loops it was executing and ended."]
pub const NiFpga_FpgaViState_NiFpga_FpgaViState_NaturallyStopped: NiFpga_FpgaViState = 3;
#[doc = " Possible FPGA VI States that GetFpgaViState will output."]
pub type NiFpga_FpgaViState = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Get the current state of the FPGA VI on the target.\n\n @param session handle to a currently open session\n @param state the current state specified as NiFpga_FpgaViState\n @return result of the call"]
    pub fn NiFpga_GetFpgaViState(session: NiFpga_Session, state: *mut u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads a boolean value from a given indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadBool(
        session: NiFpga_Session,
        indicator: u32,
        value: *mut NiFpga_Bool,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads a signed 8-bit integer value from a given indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadI8(session: NiFpga_Session, indicator: u32, value: *mut i8) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an unsigned 8-bit integer value from a given indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadU8(session: NiFpga_Session, indicator: u32, value: *mut u8) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads a signed 16-bit integer value from a given indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadI16(
        session: NiFpga_Session,
        indicator: u32,
        value: *mut i16,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an unsigned 16-bit integer value from a given indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadU16(
        session: NiFpga_Session,
        indicator: u32,
        value: *mut u16,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads a signed 32-bit integer value from a given indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadI32(
        session: NiFpga_Session,
        indicator: u32,
        value: *mut i32,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an unsigned 32-bit integer value from a given indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadU32(
        session: NiFpga_Session,
        indicator: u32,
        value: *mut u32,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads a signed 64-bit integer value from a given indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadI64(
        session: NiFpga_Session,
        indicator: u32,
        value: *mut i64,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an unsigned 64-bit integer value from a given indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadU64(
        session: NiFpga_Session,
        indicator: u32,
        value: *mut u64,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads a single-precision floating-point value from a given indicator or\n control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadSgl(
        session: NiFpga_Session,
        indicator: u32,
        value: *mut f32,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads a double-precision floating-point value from a given indicator or\n control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadDbl(
        session: NiFpga_Session,
        indicator: u32,
        value: *mut f64,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads a FXP value with a wordlength greater than 32-bits from a given\n indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param typeInfo typeInfo from the generated FXP type\n @param value outputs the value that was read\n @return result of the call"]
    pub fn NiFpga_ReadFxp64(
        session: NiFpga_Session,
        indicator: u32,
        typeInfo: NiFpga_FxpTypeInfo,
        value: *mut u64,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes a boolean value to a given control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteBool(
        session: NiFpga_Session,
        control: u32,
        value: NiFpga_Bool,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes a signed 8-bit integer value to a given control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteI8(session: NiFpga_Session, control: u32, value: i8) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an unsigned 8-bit integer value to a given control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteU8(session: NiFpga_Session, control: u32, value: u8) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes a signed 16-bit integer value to a given control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteI16(session: NiFpga_Session, control: u32, value: i16) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an unsigned 16-bit integer value to a given control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteU16(session: NiFpga_Session, control: u32, value: u16) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes a signed 32-bit integer value to a given control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteI32(session: NiFpga_Session, control: u32, value: i32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an unsigned 32-bit integer value to a given control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteU32(session: NiFpga_Session, control: u32, value: u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes a signed 64-bit integer value to a given control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteI64(session: NiFpga_Session, control: u32, value: i64) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an unsigned 64-bit integer value to a given control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteU64(session: NiFpga_Session, control: u32, value: u64) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes a single-precision floating-point value to a given control or\n indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteSgl(session: NiFpga_Session, control: u32, value: f32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes a double-precision floating-point value to a given control or\n indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteDbl(session: NiFpga_Session, control: u32, value: f64) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes a FXP value with a wordlength greater than 32-bits to a given\n indicator or control.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param typeInfo typeInfo from the generated FXP type\n @param value value to write\n @return result of the call"]
    pub fn NiFpga_WriteFxp64(
        session: NiFpga_Session,
        control: u32,
        typeInfo: NiFpga_FxpTypeInfo,
        value: u64,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of boolean values from a given array indicator or\n control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayBool(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut NiFpga_Bool,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of signed 8-bit integer values from a given array\n indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayI8(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut i8,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of unsigned 8-bit integer values from a given array\n indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayU8(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut u8,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of signed 16-bit integer values from a given array\n indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayI16(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut i16,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of unsigned 16-bit integer values from a given array\n indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayU16(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut u16,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of signed 32-bit integer values from a given array\n indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayI32(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut i32,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of unsigned 32-bit integer values from a given array\n indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayU32(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut u32,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of signed 64-bit integer values from a given array\n indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayI64(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut i64,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of unsigned 64-bit integer values from a given array\n indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayU64(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut u64,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of single-precision floating-point values from a\n given array indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArraySgl(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut f32,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads an entire array of double-precision floating-point values from a\n given array indicator or control.\n\n @warning The size passed must be the exact number of elements in the\n          indicator or control.\n\n @param session handle to a currently open session\n @param indicator indicator or control from which to read\n @param array outputs the entire array that was read\n @param size exact number of elements in the indicator or control\n @return result of the call"]
    pub fn NiFpga_ReadArrayDbl(
        session: NiFpga_Session,
        indicator: u32,
        array: *mut f64,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of boolean values to a given array control or\n indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayBool(
        session: NiFpga_Session,
        control: u32,
        array: *const NiFpga_Bool,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of signed 8-bit integer values to a given array\n control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayI8(
        session: NiFpga_Session,
        control: u32,
        array: *const i8,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of unsigned 8-bit integer values to a given array\n control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayU8(
        session: NiFpga_Session,
        control: u32,
        array: *const u8,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of signed 16-bit integer values to a given array\n control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayI16(
        session: NiFpga_Session,
        control: u32,
        array: *const i16,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of unsigned 16-bit integer values to a given array\n control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayU16(
        session: NiFpga_Session,
        control: u32,
        array: *const u16,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of signed 32-bit integer values to a given array\n control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayI32(
        session: NiFpga_Session,
        control: u32,
        array: *const i32,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of unsigned 32-bit integer values to a given array\n control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayU32(
        session: NiFpga_Session,
        control: u32,
        array: *const u32,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of signed 64-bit integer values to a given array\n control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayI64(
        session: NiFpga_Session,
        control: u32,
        array: *const i64,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of unsigned 64-bit integer values to a given array\n control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayU64(
        session: NiFpga_Session,
        control: u32,
        array: *const u64,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of single-precision floating-point values to a given\n array control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArraySgl(
        session: NiFpga_Session,
        control: u32,
        array: *const f32,
        size: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes an entire array of double-precision floating-point values to a given\n array control or indicator.\n\n @warning The size passed must be the exact number of elements in the\n          control or indicator.\n\n @param session handle to a currently open session\n @param control control or indicator to which to write\n @param array entire array to write\n @param size exact number of elements in the control or indicator\n @return result of the call"]
    pub fn NiFpga_WriteArrayDbl(
        session: NiFpga_Session,
        control: u32,
        array: *const f64,
        size: usize,
    ) -> NiFpga_Status;
}
#[doc = " Represents an infinite timeout."]
pub const NiFpga_InfiniteTimeout: u32 = 4294967295;
pub const NiFpga_Irq_NiFpga_Irq_0: NiFpga_Irq = 1;
pub const NiFpga_Irq_NiFpga_Irq_1: NiFpga_Irq = 2;
pub const NiFpga_Irq_NiFpga_Irq_2: NiFpga_Irq = 4;
pub const NiFpga_Irq_NiFpga_Irq_3: NiFpga_Irq = 8;
pub const NiFpga_Irq_NiFpga_Irq_4: NiFpga_Irq = 16;
pub const NiFpga_Irq_NiFpga_Irq_5: NiFpga_Irq = 32;
pub const NiFpga_Irq_NiFpga_Irq_6: NiFpga_Irq = 64;
pub const NiFpga_Irq_NiFpga_Irq_7: NiFpga_Irq = 128;
pub const NiFpga_Irq_NiFpga_Irq_8: NiFpga_Irq = 256;
pub const NiFpga_Irq_NiFpga_Irq_9: NiFpga_Irq = 512;
pub const NiFpga_Irq_NiFpga_Irq_10: NiFpga_Irq = 1024;
pub const NiFpga_Irq_NiFpga_Irq_11: NiFpga_Irq = 2048;
pub const NiFpga_Irq_NiFpga_Irq_12: NiFpga_Irq = 4096;
pub const NiFpga_Irq_NiFpga_Irq_13: NiFpga_Irq = 8192;
pub const NiFpga_Irq_NiFpga_Irq_14: NiFpga_Irq = 16384;
pub const NiFpga_Irq_NiFpga_Irq_15: NiFpga_Irq = 32768;
pub const NiFpga_Irq_NiFpga_Irq_16: NiFpga_Irq = 65536;
pub const NiFpga_Irq_NiFpga_Irq_17: NiFpga_Irq = 131072;
pub const NiFpga_Irq_NiFpga_Irq_18: NiFpga_Irq = 262144;
pub const NiFpga_Irq_NiFpga_Irq_19: NiFpga_Irq = 524288;
pub const NiFpga_Irq_NiFpga_Irq_20: NiFpga_Irq = 1048576;
pub const NiFpga_Irq_NiFpga_Irq_21: NiFpga_Irq = 2097152;
pub const NiFpga_Irq_NiFpga_Irq_22: NiFpga_Irq = 4194304;
pub const NiFpga_Irq_NiFpga_Irq_23: NiFpga_Irq = 8388608;
pub const NiFpga_Irq_NiFpga_Irq_24: NiFpga_Irq = 16777216;
pub const NiFpga_Irq_NiFpga_Irq_25: NiFpga_Irq = 33554432;
pub const NiFpga_Irq_NiFpga_Irq_26: NiFpga_Irq = 67108864;
pub const NiFpga_Irq_NiFpga_Irq_27: NiFpga_Irq = 134217728;
pub const NiFpga_Irq_NiFpga_Irq_28: NiFpga_Irq = 268435456;
pub const NiFpga_Irq_NiFpga_Irq_29: NiFpga_Irq = 536870912;
pub const NiFpga_Irq_NiFpga_Irq_30: NiFpga_Irq = 1073741824;
pub const NiFpga_Irq_NiFpga_Irq_31: NiFpga_Irq = 2147483648;
#[doc = " Enumeration of all 32 possible IRQs. Multiple IRQs can be bitwise ORed\n together like this:\n\n    NiFpga_Irq_3 | NiFpga_Irq_23"]
pub type NiFpga_Irq = ::std::os::raw::c_uint;
#[doc = " See NiFpga_ReserveIrqContext for more information."]
pub type NiFpga_IrqContext = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = " IRQ contexts are single-threaded; only one thread can wait with a\n particular context at any given time. To minimize jitter when first\n waiting on IRQs, reserve as many contexts as the application\n requires.\n\n If a context is successfully reserved (the returned status is not an error),\n it must be unreserved later. Otherwise a memory leak will occur.\n\n @param session handle to a currently open session\n @param context outputs the IRQ context\n @return result of the call"]
    pub fn NiFpga_ReserveIrqContext(
        session: NiFpga_Session,
        context: *mut NiFpga_IrqContext,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Unreserves an IRQ context obtained from NiFpga_ReserveIrqContext.\n\n @param session handle to a currently open session\n @param context IRQ context to unreserve\n @return result of the call"]
    pub fn NiFpga_UnreserveIrqContext(
        session: NiFpga_Session,
        context: NiFpga_IrqContext,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " This is a blocking function that stops the calling thread until the\n FPGA asserts any IRQ in the irqs parameter, or until the function\n call times out. Before calling this function, use\n NiFpga_ReserveIrqContext to reserve an IRQ context. No other\n threads can use the same context when this function is called.\n\n You can use the irqsAsserted parameter to determine which IRQs were asserted\n for each function call.\n\n @param session handle to a currently open session\n @param context IRQ context with which to wait\n @param irqs bitwise OR of NiFpga_Irqs\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param irqsAsserted if non-NULL, outputs bitwise OR of IRQs that were\n                     asserted\n @param timedOut if non-NULL, outputs whether the timeout expired\n @return result of the call"]
    pub fn NiFpga_WaitOnIrqs(
        session: NiFpga_Session,
        context: NiFpga_IrqContext,
        irqs: u32,
        timeout: u32,
        irqsAsserted: *mut u32,
        timedOut: *mut NiFpga_Bool,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acknowledges an IRQ or set of IRQs.\n\n @param session handle to a currently open session\n @param irqs bitwise OR of NiFpga_Irqs\n @return result of the call"]
    pub fn NiFpga_AcknowledgeIrqs(session: NiFpga_Session, irqs: u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Specifies the depth of the host memory part of the DMA FIFO. This method is\n optional. In order to see the actual depth configured, use\n NiFpga_ConfigureFifo2.\n\n @param session handle to a currently open session\n @param fifo FIFO to configure\n @param depth requested number of elements in the host memory part of the\n              DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ConfigureFifo(session: NiFpga_Session, fifo: u32, depth: usize) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Specifies the depth of the host memory part of the DMA FIFO. This method is\n optional.\n\n @param session handle to a currently open session\n @param fifo FIFO to configure\n @param requestedDepth requested number of elements in the host memory part\n                       of the DMA FIFO\n @param actualDepth if non-NULL, outputs the actual number of elements in the\n                    host memory part of the DMA FIFO, which may be more than\n                    the requested number\n @return result of the call"]
    pub fn NiFpga_ConfigureFifo2(
        session: NiFpga_Session,
        fifo: u32,
        requestedDepth: usize,
        actualDepth: *mut usize,
    ) -> NiFpga_Status;
}
#[doc = " BytesPerElement\n\n Type: U32\n\n Specifies the number of bytes in a single element of the FIFO. Other\n FIFO Buffer related properties are specified in number of elements, so\n this property can be used to convert that number to a number of bytes.\n\n This property is only Getable and cannot be Set."]
pub const NiFpga_FifoProperty_NiFpga_FifoProperty_BytesPerElement: NiFpga_FifoProperty = 1;
#[doc = " HostBufferAllocationGranularity\n\n Type: U32\n\n Specifies the smallest discreet allocation unit that the HostBufferSize\n will be coerced too. By default, this value will be set to the most\n optimized setting for your hardware and system. This usually ends up\n being the system's page size. The only valid values for this property\n are powers of 2."]
pub const NiFpga_FifoProperty_NiFpga_FifoProperty_HostBufferAllocationGranularity:
    NiFpga_FifoProperty = 2;
#[doc = " HostBufferSize\n\n Type: U64\n\n The number of elements in the host memory part of the DMA FIFO. This size\n will be coerced to be a multiple of the HostBufferAllocationGranularity."]
pub const NiFpga_FifoProperty_NiFpga_FifoProperty_HostBufferSize: NiFpga_FifoProperty = 3;
#[doc = " HostBufferMirrorSize\n\n Type: U64\n\n Specifies the number of elements mirrored at the end of the host memory\n part of the DMA FIFO. By mirrored, we mean that the memory is mapped in\n such a way that these elements point to the same physical memory as the\n elements at the beginning of the host memory part of the DMA FIFO.\n\n Setting up memory like this improves use with the AcquireFifoElements API.\n When using AcquireFifoElements, you can hit the end of the buffer and\n recieve less elements than you attempted to acquire. This requires a\n second AcquireFifoElements call to get the remaining elements.\n Mirroring Elements avoids that second call.\n\n Example:\n ========\n **Behavior without Mirrored Elements**:\n\n This is a Target to Host FIFO of 10 elements:\n\n        0-1-2-3-4-5-6-7-8-9\n        ^\n        Current FIFO pointer here.\n\n 1. Acquire, use and Release 7 elements.\n\n        0-1-2-3-4-5-6-7-8-9\n                      ^\n                      Current FIFO pointer here.\n\n 2. The device writes to those 7 elements, filling up the FIFO.\n 3. Attempt to acquire 7 elements, get back 3 because we can only give a\n    pointer to 3 elements.\n\n **Behavior with Mirrored Elements**:\n\n If instead we had mirrored 4 elements, it would act like this.\n\n        0-1-2-3-4-5-6-7-8-9{0-1-2-3}\n        ^                   ^mirrored elements\n        Current FIFO pointer here.\n\n 1. Acquire, use and Release 7 elements.\n\n        0-1-2-3-4-5-6-7-8-9{0-1-2-3}\n                      ^     ^mirrored elements\n                      Current FIFO pointer here.\n\n 2. The device writes to those 7 elements, filling up the FIFO.\n 3. Acquire, use and Release 7 elements. No problems are encountered\n    because the driver gives back a pointer to the 7 elements requested."]
pub const NiFpga_FifoProperty_NiFpga_FifoProperty_HostBufferMirrorSize: NiFpga_FifoProperty = 4;
#[doc = " HostBufferType\n\n Type: I32\n\n Specifies the type of memory used in the host memory part of the DMA FIFO.\n See NiFpga_HostBufferType for the valid values of this property."]
pub const NiFpga_FifoProperty_NiFpga_FifoProperty_HostBufferType: NiFpga_FifoProperty = 5;
#[doc = " HostBuffer\n\n Type: Ptr\n\n Specifies a pointer to the start of the host memory part of the DMA FIFO.\n Can only be set if the HostBufferType is set to\n NiFpga_HostBufferType_AllocatedByUser.\n\n Note, if the buffer is user supplied, the buffer will be pagelocked\n by the driver. When the user has finished with the buffer, the user must\n do one of the following before deallocating the buffer:\n 1. Call NiFpga_Close on the NiFpga_Session\n 2. Set the buffer type to NiFpga_HostBufferType_AllocatedByRIO and call\n    NiFpga_CommitFifoConfiguration.\n 3. Set the NiFpga_FifoProperty_HostBuffer to a different buffer.\n 4. End the process."]
pub const NiFpga_FifoProperty_NiFpga_FifoProperty_HostBuffer: NiFpga_FifoProperty = 6;
#[doc = " FlowControl\n\n Type: I32\n\n Specifies the flow control behavior of the DMA FIFO.\n See NiFpga_FifoFlowControl for specifics on the behaviors.\n Note, changing the behavior of a FIFO can make it work in a non-\"first in\n first out\" manner."]
pub const NiFpga_FifoProperty_NiFpga_FifoProperty_FlowControl: NiFpga_FifoProperty = 7;
#[doc = " ElementsCurrentlyAcquired\n\n Type: U64\n\n Specifies the number of elements that are currently acquired by the user\n using the NiFpga_AcquireFifoReadElements* functions that have not yet\n been released.\n\n This property is only Getable and cannot be Set."]
pub const NiFpga_FifoProperty_NiFpga_FifoProperty_ElementsCurrentlyAcquired: NiFpga_FifoProperty =
    8;
pub type NiFpga_FifoProperty = ::std::os::raw::c_uint;
#[doc = " Specifies that the DMA Buffer will be allocated by the NI-RIO driver\n according to the options specified in the other FIFO properties."]
pub const NiFpga_HostBufferType_NiFpga_HostBufferType_AllocatedByRIO: NiFpga_HostBufferType = 1;
#[doc = " Specifies that the user has allocated the FIFO to the options specified\n in the other FIFO properties. After setting this property, the user\n should set NiFpga_FifoProperty_HostBuffer to their specified buffer."]
pub const NiFpga_HostBufferType_NiFpga_HostBufferType_AllocatedByUser: NiFpga_HostBufferType = 2;
pub type NiFpga_HostBufferType = ::std::os::raw::c_uint;
#[doc = " When this option is specified, the FPGA will fully control data transfer\n without any action from the host. FIFOs will no longer act in a first\n in first out manner. It is up to the user to synchronize with the FPGA\n and ensure coherent data.\n\n For Target To Host FIFOs, data will being transferring on StartFifo.\n For Host To Target FIFOs, data will begin transferring when the entire\n host part of the DMA FIFO has been written once. This is intended to\n prevent the FPGA from reading garbage data from an uninitialized buffer\n on the host."]
pub const NiFpga_FifoFlowControl_NiFpga_FifoFlowControl_Disabled: NiFpga_FifoFlowControl = 1;
#[doc = " This is the default options for FIFOs. When this option is specified,\n FIFOs act with First In First Out behavior and no data is ever lost.\n Data will stop transferring if the host memory part of the FIFO becomes\n full rather than overwriting it."]
pub const NiFpga_FifoFlowControl_NiFpga_FifoFlowControl_Enabled: NiFpga_FifoFlowControl = 2;
pub type NiFpga_FifoFlowControl = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Sets the specified U32 FIFO property to the requested value. The specified\n value may be coerced to a different value if nessessary. The FIFO must be\n stopped before using this function.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to set\n @param value the desired value of the property\n @return result of the call"]
    pub fn NiFpga_SetFifoPropertyU32(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: u32,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Sets the specified I32 FIFO property to the requested value. The specified\n value may be coerced to a different value if nessessary. The FIFO must be\n stopped before using this function.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to set\n @param value the desired value of the property\n @return result of the call"]
    pub fn NiFpga_SetFifoPropertyI32(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: i32,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Sets the specified U64 FIFO property to the requested value. The specified\n value may be coerced to a different value if nessessary. The FIFO must be\n stopped before using this function.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to set\n @param value the desired value of the property\n @return result of the call"]
    pub fn NiFpga_SetFifoPropertyU64(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: u64,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Sets the specified I64 FIFO property to the requested value. The specified\n value may be coerced to a different value if nessessary. The FIFO must be\n stopped before using this function.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to set\n @param value the desired value of the property\n @return result of the call"]
    pub fn NiFpga_SetFifoPropertyI64(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: i64,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Sets the specified pointer FIFO property to the requested value. The\n specified value may be coerced to a different value if nessessary. The FIFO\n must be stopped before using this function.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to set\n @param value the desired value of the property\n @return result of the call"]
    pub fn NiFpga_SetFifoPropertyPtr(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: *mut ::std::os::raw::c_void,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Gets the value of the specified U32 FIFO property. The value returned may be\n coerced from the value set. The value returned will be used by the FIFO.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to get\n @param value the actual value of the property\n @return result of the call"]
    pub fn NiFpga_GetFifoPropertyU32(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: *mut u32,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Gets the value of the specified I32 FIFO property. The value returned may be\n coerced from the value set. The value returned will be used by the FIFO.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to get\n @param value the actual value of the property\n @return result of the call"]
    pub fn NiFpga_GetFifoPropertyI32(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: *mut i32,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Gets the value of the specified U64 FIFO property. The value returned may be\n coerced from the value set. The value returned will be used by the FIFO.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to get\n @param value the actual value of the property\n @return result of the call"]
    pub fn NiFpga_GetFifoPropertyU64(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: *mut u64,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Gets the value of the specified I64 FIFO property. The value returned may be\n coerced from the value set. The value returned will be used by the FIFO.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to get\n @param value the actual value of the property\n @return result of the call"]
    pub fn NiFpga_GetFifoPropertyI64(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: *mut i64,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Gets the value of the specified pointer FIFO property. The value returned may\n be coerced from the value set. The value returned will be used by the FIFO.\n\n @param session handle to a currently open session\n @param fifo FIFO to use\n @param property NiFpga_FifoProperty to get\n @param value the actual value of the property\n @return result of the call"]
    pub fn NiFpga_GetFifoPropertyPtr(
        session: NiFpga_Session,
        fifo: u32,
        property: NiFpga_FifoProperty,
        value: *mut *mut ::std::os::raw::c_void,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Commits the configuration of the FIFO. Resolves the host memory part of the\n DMA FIFO and commits FIFO properties to the driver. The FIFO must be stopped\n to call this function.\n\n @param session handle to a currently open session\n @param fifo FIFO to commit configuration\n @return result of the call"]
    pub fn NiFpga_CommitFifoConfiguration(session: NiFpga_Session, fifo: u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Starts a FIFO. This method is optional.\n\n @param session handle to a currently open session\n @param fifo FIFO to start\n @return result of the call"]
    pub fn NiFpga_StartFifo(session: NiFpga_Session, fifo: u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Stops a FIFO. This method is optional.\n\n @param session handle to a currently open session\n @param fifo FIFO to stop\n @return result of the call"]
    pub fn NiFpga_StopFifo(session: NiFpga_Session, fifo: u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Unreserves a FIFO. This method is optional. FIFOs are only usable in the\n process that first uses them.  This function releases a FIFO from the using\n session and process so a session in a different process can use the FIFO.\n\n @param session handle to a currently open session\n @param fifo FIFO to unreserve\n @return result of the call"]
    pub fn NiFpga_UnreserveFifo(session: NiFpga_Session, fifo: u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of booleans.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoBool(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut NiFpga_Bool,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of signed 8-bit integers.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoI8(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut i8,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of unsigned 8-bit integers.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoU8(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut u8,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of signed 16-bit integers.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoI16(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut i16,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of unsigned 16-bit integers.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoU16(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut u16,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of signed 32-bit integers.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoI32(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut i32,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of unsigned 32-bit integers.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoU32(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut u32,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of signed 64-bit integers.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoI64(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut i64,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of unsigned 64-bit integers.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoU64(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut u64,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of single-precision floating-point values.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoSgl(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut f32,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of double-precision floating-point values.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoDbl(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut f64,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Reads from a target-to-host FIFO of composite types such as clusters.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param data outputs the data that was read\n @param bytesPerElement the size in bytes of each element\n @param numberOfElements number of elements to read\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_ReadFifoComposite(
        session: NiFpga_Session,
        fifo: u32,
        data: *mut ::std::os::raw::c_void,
        bytesPerElement: u32,
        numberOfElements: usize,
        timeout: u32,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of booleans.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoBool(
        session: NiFpga_Session,
        fifo: u32,
        data: *const NiFpga_Bool,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of signed 8-bit integers.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoI8(
        session: NiFpga_Session,
        fifo: u32,
        data: *const i8,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of unsigned 8-bit integers.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoU8(
        session: NiFpga_Session,
        fifo: u32,
        data: *const u8,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of signed 16-bit integers.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoI16(
        session: NiFpga_Session,
        fifo: u32,
        data: *const i16,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of unsigned 16-bit integers.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoU16(
        session: NiFpga_Session,
        fifo: u32,
        data: *const u16,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of signed 32-bit integers.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoI32(
        session: NiFpga_Session,
        fifo: u32,
        data: *const i32,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of unsigned 32-bit integers.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoU32(
        session: NiFpga_Session,
        fifo: u32,
        data: *const u32,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of signed 64-bit integers.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoI64(
        session: NiFpga_Session,
        fifo: u32,
        data: *const i64,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of unsigned 64-bit integers.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoU64(
        session: NiFpga_Session,
        fifo: u32,
        data: *const u64,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of single-precision floating-point values.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoSgl(
        session: NiFpga_Session,
        fifo: u32,
        data: *const f32,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of double-precision floating-point values.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoDbl(
        session: NiFpga_Session,
        fifo: u32,
        data: *const f64,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Writes to a host-to-target FIFO of composite types such as clusters.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param data data to write\n @param bytesPerElement the size in bytes of each element\n @param numberOfElements number of elements to write\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param emptyElementsRemaining if non-NULL, outputs the number of empty\n                               elements remaining in the host memory part of\n                               the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_WriteFifoComposite(
        session: NiFpga_Session,
        fifo: u32,
        data: *const ::std::os::raw::c_void,
        bytesPerElement: u32,
        numberOfElements: usize,
        timeout: u32,
        emptyElementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of booleans.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsBool(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut NiFpga_Bool,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of signed 8-bit\n integers.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsI8(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut i8,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of unsigned 8-bit\n integers.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsU8(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut u8,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of signed 16-bit\n integers.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsI16(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut i16,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of unsigned 16-bit\n integers.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsU16(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut u16,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of signed 32-bit\n integers.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsI32(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut i32,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of unsigned 32-bit\n integers.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsU32(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut u32,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of signed 64-bit\n integers.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsI64(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut i64,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of unsigned 64-bit\n integers.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsU64(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut u64,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of single-precision\n floating-point values.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsSgl(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut f32,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for reading from a target-to-host FIFO of double-precision\n floating-point values.\n\n Acquiring, reading, and releasing FIFO elements prevents the need to copy\n the contents of elements from the host memory buffer to a separate\n user-allocated buffer before reading. The FPGA target cannot write to\n elements acquired by the host. Therefore, the host must release elements\n after reading them. The number of elements acquired may differ from the\n number of elements requested if, for example, the number of elements\n requested reaches the end of the host memory buffer. Always release all\n acquired elements before closing the session. Do not attempt to access FIFO\n elements after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo target-to-host FIFO from which to read\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoReadElementsDbl(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut f64,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of booleans.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsBool(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut NiFpga_Bool,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of signed 8-bit\n integers.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsI8(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut i8,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of unsigned 8-bit\n integers.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsU8(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut u8,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of signed 16-bit\n integers.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsI16(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut i16,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of unsigned 16-bit\n integers.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsU16(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut u16,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of signed 32-bit\n integers.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsI32(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut i32,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of unsigned 32-bit\n integers.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsU32(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut u32,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of signed 64-bit\n integers.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsI64(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut i64,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of unsigned 64-bit\n integers.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsU64(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut u64,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of single-precision\n floating-point values.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsSgl(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut f32,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Acquires elements for writing to a host-to-target FIFO of single-precision\n floating-point values.\n\n Acquiring, writing, and releasing FIFO elements prevents the need to write\n first into a separate user-allocated buffer and then copy the contents of\n elements to the host memory buffer. The FPGA target cannot read elements\n acquired by the host. Therefore, the host must release elements after\n writing to them. The number of elements acquired may differ from the number\n of elements requested if, for example, the number of elements requested\n reaches the end of the host memory buffer. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo host-to-target FIFO to which to write\n @param elements outputs a pointer to the elements acquired\n @param elementsRequested requested number of elements\n @param timeout timeout in milliseconds, or NiFpga_InfiniteTimeout\n @param elementsAcquired actual number of elements acquired, which may be\n                         less than the requested number\n @param elementsRemaining if non-NULL, outputs the number of elements\n                          remaining in the host memory part of the DMA FIFO\n @return result of the call"]
    pub fn NiFpga_AcquireFifoWriteElementsDbl(
        session: NiFpga_Session,
        fifo: u32,
        elements: *mut *mut f64,
        elementsRequested: usize,
        timeout: u32,
        elementsAcquired: *mut usize,
        elementsRemaining: *mut usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Releases previously acquired FIFO elements.\n\n The FPGA target cannot read elements acquired by the host. Therefore, the\n host must release elements after acquiring them. Always release all acquired\n elements before closing the session. Do not attempt to access FIFO elements\n after the elements are released or the session is closed.\n\n @param session handle to a currently open session\n @param fifo FIFO from which to release elements\n @param elements number of elements to release\n @return result of the call"]
    pub fn NiFpga_ReleaseFifoElements(
        session: NiFpga_Session,
        fifo: u32,
        elements: usize,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Gets an endpoint reference to a peer-to-peer FIFO.\n\n @param session handle to a currently open session\n @param fifo peer-to-peer FIFO\n @param endpoint Outputs the endpoint reference.\n                 The actual type is a nip2p_tEndpointHandle usable by\n                 the NI Peer-to-Peer Streaming C/C++ API.\n @return result of the call"]
    pub fn NiFpga_GetPeerToPeerFifoEndpoint(
        session: NiFpga_Session,
        fifo: u32,
        endpoint: *mut u32,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Maps the write window of a peer-to-peer reader FIFO.\n\n The P2P reader expects linear accesses to the memory. This means that the\n libc memcpy is probably not safe and will cause out-of-order data writes.\n\n This memory may not be read from. Doing so could cause a bus hang on some\n targets. This includes reads issued by a debugger. Proceed with caution.\n\n This FIFO must be unmapped before a new FPGA image can be downloaded.\n\n @param session handle to a currently open session\n @param fifo peer-to-peer Sink FIFO\n @param size Outputs the size of the mapped region.\n @param virtualAddress Outputs the base address of the mapped region.\n @return result of the call"]
    pub fn NiFpga_MapP2PSinkFifo(
        session: NiFpga_Session,
        fifo: u32,
        size: *mut usize,
        virtualAddress: *mut *mut ::std::os::raw::c_void,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Unmaps the write window of a peer-to-peer reader FIFO.\n\n @param session handle used to map the FIFO\n @param fifo peer-to-peer Sink FIFO"]
    pub fn NiFpga_UnmapP2PSinkFifo(session: NiFpga_Session, fifo: u32) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Open a Host Memory Buffer\n\n If the target supports creating a Host Memory Buffer, open the memory region\n mapped into the calling process.\n\n Call NiFpga_CloseHostMemoryBuffer to unmap and close the HMB.\n\n @param session handle to a currently open session\n @param memoryName Name given to the memory in the FPGA target\n @param memorySize Outputs the size of the mapped region.\n @param virtualAddress Outputs the base address of the mapped region.\n @return result of the call"]
    pub fn NiFpga_OpenHostMemoryBuffer(
        session: NiFpga_Session,
        memoryName: *const ::std::os::raw::c_char,
        memorySize: *mut usize,
        virtualAddress: *mut *mut ::std::os::raw::c_void,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Unmaps and closes the Host Memory Buffer\n\n @param session handle used to open the HMB\n @param memoryName Name given to the memory in the FPGA target"]
    pub fn NiFpga_CloseHostMemoryBuffer(
        session: NiFpga_Session,
        memoryName: *const ::std::os::raw::c_char,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Open a Low Latency Buffer\n\n If the target supports creating a Low Latency Buffer, open the two memory\n regions mapped into the calling process.\n\n Each mapped memory space is unidirectional allowing posted writes in each\n direction for low-latency memory accesses between host and FPGA.\n\n Call NiFpga_CloseLowLatencyBuffer to unmap and close the LLB.\n\n @param session handle to a currently open session\n @param memoryName Name given to the memory in the FPGA target\n @param memorySizeToHost Outputs the size of the mapped region the FPGA writes to the Host.\n @param virtualAddressToHost Outputs the base address of the mapped region the FPGA writes to the Host.\n @param memorySizeToFpga Outputs the size of the mapped region the Host writes to the FPGA.\n @param virtualAddressToFpga Outputs the base address of the mapped region the Host writes to the FPGA.\n @return result of the call"]
    pub fn NiFpga_OpenLowLatencyBuffer(
        session: NiFpga_Session,
        memoryName: *const ::std::os::raw::c_char,
        memorySizeToHost: *mut usize,
        virtualAddressToHost: *mut *mut ::std::os::raw::c_void,
        memorySizeToFpga: *mut usize,
        virtualAddressToFpga: *mut *mut ::std::os::raw::c_void,
    ) -> NiFpga_Status;
}
extern "C" {
    #[doc = " Unmaps and closes the Low Latency Buffer\n\n @param session handle used to open the LLB\n @param memoryName Name given to the memory in the FPGA target"]
    pub fn NiFpga_CloseLowLatencyBuffer(
        session: NiFpga_Session,
        memoryName: *const ::std::os::raw::c_char,
    ) -> NiFpga_Status;
}
