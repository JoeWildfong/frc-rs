/* automatically generated by rust-bindgen 0.69.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const CAN_IS_FRAME_REMOTE: u32 = 2147483648;
pub const CAN_IS_FRAME_11BIT: u32 = 1073741824;
pub const CAN_29BIT_MESSAGE_ID_MASK: u32 = 536870911;
pub const CAN_11BIT_MESSAGE_ID_MASK: u32 = 2047;
pub const CAN_SEND_PERIOD_NO_REPEAT: u32 = 0;
pub const CAN_SEND_PERIOD_STOP_REPEATING: i32 = -1;
pub const ERR_CANSessionMux_InvalidBuffer: i32 = -44086;
pub const ERR_CANSessionMux_MessageNotFound: i32 = -44087;
pub const WARN_CANSessionMux_NoToken: u32 = 44087;
pub const ERR_CANSessionMux_NotAllowed: i32 = -44088;
pub const ERR_CANSessionMux_NotInitialized: i32 = -44089;
pub const ERR_CANSessionMux_SessionOverrun: u32 = 44050;
pub const ERR_FRCSystem_NetCommNotResponding: i32 = -44049;
pub const ERR_FRCSystem_NoDSConnection: i32 = -44018;
pub const kTcpRecvMask_Joysticks: u32 = 255;
pub const kTcpRecvMask_MatchInfoOld: u32 = 256;
pub const kTcpRecvMask_MatchInfo: u32 = 512;
pub const kTcpRecvMask_GameSpecific: u32 = 1024;
pub const kMaxModuleNumber: u32 = 2;
pub const kUsageReporting_version: u32 = 1;
extern "C" {
    pub fn FRC_NetworkCommunication_nAICalibration_getLSBWeight(
        aiSystemIndex: u32,
        channel: u32,
        status: *mut i32,
    ) -> u32;
}
extern "C" {
    pub fn FRC_NetworkCommunication_nAICalibration_getOffset(
        aiSystemIndex: u32,
        channel: u32,
        status: *mut i32,
    ) -> i32;
}
#[repr(C)]
pub struct CANInterfacePlugin__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct CANInterfacePlugin {
    pub vtable_: *const CANInterfacePlugin__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_CANInterfacePlugin() {
    assert_eq!(
        ::std::mem::size_of::<CANInterfacePlugin>(),
        4usize,
        concat!("Size of: ", stringify!(CANInterfacePlugin))
    );
    assert_eq!(
        ::std::mem::align_of::<CANInterfacePlugin>(),
        4usize,
        concat!("Alignment of ", stringify!(CANInterfacePlugin))
    );
}
extern "C" {
    #[doc = " This function allows you to register a CANInterfacePlugin to provide access a CAN bus.\n\n @param interface A pointer to an object that inherits from CANInterfacePlugin and implements\n the pure virtual interface.  If NULL, unregister the current plugin."]
    #[link_name = "\u{1}_Z56FRC_NetworkCommunication_CANSessionMux_registerInterfaceP18CANInterfacePlugin"]
    pub fn FRC_NetworkCommunication_CANSessionMux_registerInterface(
        interface: *mut CANInterfacePlugin,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tCANStreamMessage {
    pub messageID: u32,
    pub timeStamp: u32,
    pub data: [u8; 8usize],
    pub dataSize: u8,
}
#[test]
fn bindgen_test_layout_tCANStreamMessage() {
    const UNINIT: ::std::mem::MaybeUninit<tCANStreamMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tCANStreamMessage>(),
        20usize,
        concat!("Size of: ", stringify!(tCANStreamMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<tCANStreamMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(tCANStreamMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tCANStreamMessage),
            "::",
            stringify!(messageID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tCANStreamMessage),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tCANStreamMessage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tCANStreamMessage),
            "::",
            stringify!(dataSize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14nCANSessionMux19sendMessage_wrapperEjPKhhiPi"]
    pub fn nCANSessionMux_sendMessage_wrapper(
        messageID: u32,
        data: *const u8,
        dataSize: u8,
        periodMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14nCANSessionMux22receiveMessage_wrapperEPjjPhS1_S0_Pi"]
    pub fn nCANSessionMux_receiveMessage_wrapper(
        messageID: *mut u32,
        messageIDMask: u32,
        data: *mut u8,
        dataSize: *mut u8,
        timeStamp: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14nCANSessionMux18resetPeriodicSendsEv"]
    pub fn nCANSessionMux_resetPeriodicSends();
}
extern "C" {
    #[link_name = "\u{1}_ZN14nCANSessionMux17openStreamSessionEPjjjjPi"]
    pub fn nCANSessionMux_openStreamSession(
        sessionHandle: *mut u32,
        messageID: u32,
        messageIDMask: u32,
        maxMessages: u32,
        status: *mut i32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14nCANSessionMux18closeStreamSessionEj"]
    pub fn nCANSessionMux_closeStreamSession(sessionHandle: u32);
}
extern "C" {
    #[link_name = "\u{1}_ZN14nCANSessionMux17readStreamSessionEjP17tCANStreamMessagejPjPi"]
    pub fn nCANSessionMux_readStreamSession(
        sessionHandle: u32,
        messages: *mut tCANStreamMessage,
        messagesToRead: u32,
        messagesRead: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN14nCANSessionMux12getCANStatusEPfPjS1_S1_S1_Pi"]
    pub fn nCANSessionMux_getCANStatus(
        percentBusUtilization: *mut f32,
        busOffCount: *mut u32,
        txFullCount: *mut u32,
        receiveErrorCount: *mut u32,
        transmitErrorCount: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_sendMessage(
        messageID: u32,
        data: *const u8,
        dataSize: u8,
        periodMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_receiveMessage(
        messageID: *mut u32,
        messageIDMask: u32,
        data: *mut u8,
        dataSize: *mut u8,
        timeStamp: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_resetPeriodicSends();
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_openStreamSession(
        sessionHandle: *mut u32,
        messageID: u32,
        messageIDMask: u32,
        maxMessages: u32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_closeStreamSession(sessionHandle: u32);
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_readStreamSession(
        sessionHandle: u32,
        messages: *mut tCANStreamMessage,
        messagesToRead: u32,
        messagesRead: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn FRC_NetworkCommunication_CANSessionMux_getCANStatus(
        percentBusUtilization: *mut f32,
        busOffCount: *mut u32,
        txFullCount: *mut u32,
        receiveErrorCount: *mut u32,
        transmitErrorCount: *mut u32,
        status: *mut i32,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__futex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__total_seq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__total_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wakeup_seq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wakeup_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__woken_seq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__woken_seq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mutex) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nwaiters) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__nwaiters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__broadcast_seq) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__broadcast_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
pub const AllianceStationID_t_kAllianceStationID_red1: AllianceStationID_t = 0;
pub const AllianceStationID_t_kAllianceStationID_red2: AllianceStationID_t = 1;
pub const AllianceStationID_t_kAllianceStationID_red3: AllianceStationID_t = 2;
pub const AllianceStationID_t_kAllianceStationID_blue1: AllianceStationID_t = 3;
pub const AllianceStationID_t_kAllianceStationID_blue2: AllianceStationID_t = 4;
pub const AllianceStationID_t_kAllianceStationID_blue3: AllianceStationID_t = 5;
pub type AllianceStationID_t = ::std::os::raw::c_uint;
pub const MatchType_t_kMatchType_none: MatchType_t = 0;
pub const MatchType_t_kMatchType_practice: MatchType_t = 1;
pub const MatchType_t_kMatchType_qualification: MatchType_t = 2;
pub const MatchType_t_kMatchType_elimination: MatchType_t = 3;
pub type MatchType_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ControlWord_t {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ControlWord_t() {
    assert_eq!(
        ::std::mem::size_of::<ControlWord_t>(),
        4usize,
        concat!("Size of: ", stringify!(ControlWord_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ControlWord_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ControlWord_t))
    );
}
impl ControlWord_t {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn test(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eStop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eStop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fmsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fmsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn control_reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_control_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: u32,
        autonomous: u32,
        test: u32,
        eStop: u32,
        fmsAttached: u32,
        dsAttached: u32,
        control_reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let test: u32 = unsafe { ::std::mem::transmute(test) };
            test as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let eStop: u32 = unsafe { ::std::mem::transmute(eStop) };
            eStop as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fmsAttached: u32 = unsafe { ::std::mem::transmute(fmsAttached) };
            fmsAttached as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsAttached: u32 = unsafe { ::std::mem::transmute(dsAttached) };
            dsAttached as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let control_reserved: u32 = unsafe { ::std::mem::transmute(control_reserved) };
            control_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoystickAxes_t {
    pub count: u16,
    pub axes: [i16; 1usize],
}
#[test]
fn bindgen_test_layout_JoystickAxes_t() {
    const UNINIT: ::std::mem::MaybeUninit<JoystickAxes_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JoystickAxes_t>(),
        4usize,
        concat!("Size of: ", stringify!(JoystickAxes_t))
    );
    assert_eq!(
        ::std::mem::align_of::<JoystickAxes_t>(),
        2usize,
        concat!("Alignment of ", stringify!(JoystickAxes_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoystickAxes_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axes) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(JoystickAxes_t),
            "::",
            stringify!(axes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JoystickPOV_t {
    pub count: u16,
    pub povs: [i16; 1usize],
}
#[test]
fn bindgen_test_layout_JoystickPOV_t() {
    const UNINIT: ::std::mem::MaybeUninit<JoystickPOV_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JoystickPOV_t>(),
        4usize,
        concat!("Size of: ", stringify!(JoystickPOV_t))
    );
    assert_eq!(
        ::std::mem::align_of::<JoystickPOV_t>(),
        2usize,
        concat!("Alignment of ", stringify!(JoystickPOV_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JoystickPOV_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).povs) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(JoystickPOV_t),
            "::",
            stringify!(povs)
        )
    );
}
extern "C" {
    pub fn FRC_NetworkCommunication_Reserve(
        instance: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getFPGAHardwareVersion(fpgaVersion: *mut u16, fpgaRevision: *mut u32);
}
extern "C" {
    pub fn FRC_NetworkCommunication_getFPGAFileName(fileName: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Safely copy data into the status packet to be sent back to the driver station.\n @deprecated battery is the only parameter to this function that is still used, and only on cRIO / simulation."]
    pub fn setStatusData(
        battery: f32,
        dsDigitalOut: u8,
        updateNumber: u8,
        userDataHigh: *const ::std::os::raw::c_char,
        userDataHighLength: ::std::os::raw::c_int,
        userDataLow: *const ::std::os::raw::c_char,
        userDataLowLength: ::std::os::raw::c_int,
        wait_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send error data to the DS\n @deprecated This old method is hard to parse on the DS side. It will be removed soon. Use FRC_NetworkCommunication_sendError instead.\n @param errorData is a cstr of the error message\n @param errorDataLength is the length of the errorData\n @param wait_ms is ignored (included for binary compatibility)\n @return 0 on success, 1 on no DS connection"]
    pub fn setErrorData(
        errors: *const ::std::os::raw::c_char,
        errorsLength: ::std::os::raw::c_int,
        wait_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send a console output line to the Driver Station\n @param line a null-terminated string\n @return 0 on success, other on failure"]
    pub fn FRC_NetworkCommunication_sendConsoleLine(
        line: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Send an error to the Driver Station\n @param isError true if error, false if warning\n @param errorCode value of error condition\n @param isLVCode true if error code is defined in errors.txt, false if not (i.e. made up for C++)\n @param details error description that contains details such as which resource number caused the failure\n @param location Source file, function, and line number that the error was generated - optional\n @param callStack The details about what functions were called through before the error was reported - optional\n @return 0 on success, other on failure"]
    pub fn FRC_NetworkCommunication_sendError(
        isError: ::std::os::raw::c_int,
        errorCode: i32,
        isLVCode: ::std::os::raw::c_int,
        details: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
        callStack: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setNewDataSem(arg1: *mut pthread_cond_t);
}
extern "C" {
    pub fn FRC_NetworkCommunication_setNewTcpDataSem(arg1: *mut pthread_cond_t);
}
extern "C" {
    pub fn setNewDataOccurRef(refnum: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_setNewTcpDataOccurRef(refnum: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getNewTcpRecvMask() -> u32;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getControlWord(
        controlWord: *mut ControlWord_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getWatchdogActive() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getAllianceStation(
        allianceStation: *mut AllianceStationID_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getMatchInfo(
        eventName: *mut ::std::os::raw::c_char,
        matchType: *mut MatchType_t,
        matchNumber: *mut u16,
        replayNumber: *mut u8,
        gameSpecificMessage: *mut u8,
        gameSpecificMessageSize: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getMatchTime(matchTime: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getJoystickAxes(
        joystickNum: u8,
        axes: *mut JoystickAxes_t,
        maxAxes: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getJoystickButtons(
        joystickNum: u8,
        buttons: *mut u32,
        count: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getJoystickPOVs(
        joystickNum: u8,
        povs: *mut JoystickPOV_t,
        maxPOVs: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_setJoystickOutputs(
        joystickNum: u8,
        hidOutputs: u32,
        leftRumble: u16,
        rightRumble: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getJoystickDesc(
        joystickNum: u8,
        isXBox: *mut u8,
        type_: *mut u8,
        name: *mut ::std::os::raw::c_char,
        axisCount: *mut u8,
        axisTypes: *mut u8,
        buttonCount: *mut u8,
        povCount: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getPDPType(pdpType: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getTimeWasSet(timeWasSet: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_getVersionString(version: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn FRC_NetworkCommunication_observeUserProgramStarting() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn FRC_NetworkCommunication_observeUserProgramDisabled();
}
extern "C" {
    pub fn FRC_NetworkCommunication_observeUserProgramAutonomous();
}
extern "C" {
    pub fn FRC_NetworkCommunication_observeUserProgramTeleop();
}
extern "C" {
    pub fn FRC_NetworkCommunication_observeUserProgramTest();
}
pub const nLoadOut_tTargetClass_kTargetClass_Unknown: nLoadOut_tTargetClass = 0;
pub const nLoadOut_tTargetClass_kTargetClass_FRC1: nLoadOut_tTargetClass = 16;
pub const nLoadOut_tTargetClass_kTargetClass_FRC2: nLoadOut_tTargetClass = 32;
pub const nLoadOut_tTargetClass_kTargetClass_FRC3: nLoadOut_tTargetClass = 48;
pub const nLoadOut_tTargetClass_kTargetClass_RoboRIO: nLoadOut_tTargetClass = 64;
pub const nLoadOut_tTargetClass_kTargetClass_RoboRIO2: nLoadOut_tTargetClass = 80;
pub const nLoadOut_tTargetClass_kTargetClass_FamilyMask: nLoadOut_tTargetClass = 240;
pub const nLoadOut_tTargetClass_kTargetClass_ModuleMask: nLoadOut_tTargetClass = 15;
pub type nLoadOut_tTargetClass = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN8nLoadOut14getTargetClassEv"]
    pub fn nLoadOut_getTargetClass() -> nLoadOut_tTargetClass;
}
extern "C" {
    pub fn FRC_NetworkCommunication_nLoadOut_getTargetClass() -> u32;
}
extern "C" {
    pub fn NetCommRPCProxy_SetOccurFuncPointer(
        Occur: ::std::option::Option<unsafe extern "C" fn(arg1: u32)>,
    );
}
pub const nUsageReporting_tResourceType_kResourceType_Controller: nUsageReporting_tResourceType = 0;
pub const nUsageReporting_tResourceType_kResourceType_Module: nUsageReporting_tResourceType = 1;
pub const nUsageReporting_tResourceType_kResourceType_Language: nUsageReporting_tResourceType = 2;
pub const nUsageReporting_tResourceType_kResourceType_CANPlugin: nUsageReporting_tResourceType = 3;
pub const nUsageReporting_tResourceType_kResourceType_Accelerometer: nUsageReporting_tResourceType =
    4;
pub const nUsageReporting_tResourceType_kResourceType_ADXL345: nUsageReporting_tResourceType = 5;
pub const nUsageReporting_tResourceType_kResourceType_AnalogChannel: nUsageReporting_tResourceType =
    6;
pub const nUsageReporting_tResourceType_kResourceType_AnalogTrigger: nUsageReporting_tResourceType =
    7;
pub const nUsageReporting_tResourceType_kResourceType_AnalogTriggerOutput:
    nUsageReporting_tResourceType = 8;
pub const nUsageReporting_tResourceType_kResourceType_CANJaguar: nUsageReporting_tResourceType = 9;
pub const nUsageReporting_tResourceType_kResourceType_Compressor: nUsageReporting_tResourceType =
    10;
pub const nUsageReporting_tResourceType_kResourceType_Counter: nUsageReporting_tResourceType = 11;
pub const nUsageReporting_tResourceType_kResourceType_Dashboard: nUsageReporting_tResourceType = 12;
pub const nUsageReporting_tResourceType_kResourceType_DigitalInput: nUsageReporting_tResourceType =
    13;
pub const nUsageReporting_tResourceType_kResourceType_DigitalOutput: nUsageReporting_tResourceType =
    14;
pub const nUsageReporting_tResourceType_kResourceType_DriverStationCIO:
    nUsageReporting_tResourceType = 15;
pub const nUsageReporting_tResourceType_kResourceType_DriverStationEIO:
    nUsageReporting_tResourceType = 16;
pub const nUsageReporting_tResourceType_kResourceType_DriverStationLCD:
    nUsageReporting_tResourceType = 17;
pub const nUsageReporting_tResourceType_kResourceType_Encoder: nUsageReporting_tResourceType = 18;
pub const nUsageReporting_tResourceType_kResourceType_GearTooth: nUsageReporting_tResourceType = 19;
pub const nUsageReporting_tResourceType_kResourceType_Gyro: nUsageReporting_tResourceType = 20;
pub const nUsageReporting_tResourceType_kResourceType_I2C: nUsageReporting_tResourceType = 21;
pub const nUsageReporting_tResourceType_kResourceType_Framework: nUsageReporting_tResourceType = 22;
pub const nUsageReporting_tResourceType_kResourceType_Jaguar: nUsageReporting_tResourceType = 23;
pub const nUsageReporting_tResourceType_kResourceType_Joystick: nUsageReporting_tResourceType = 24;
pub const nUsageReporting_tResourceType_kResourceType_Kinect: nUsageReporting_tResourceType = 25;
pub const nUsageReporting_tResourceType_kResourceType_KinectStick: nUsageReporting_tResourceType =
    26;
pub const nUsageReporting_tResourceType_kResourceType_PIDController: nUsageReporting_tResourceType =
    27;
pub const nUsageReporting_tResourceType_kResourceType_Preferences: nUsageReporting_tResourceType =
    28;
pub const nUsageReporting_tResourceType_kResourceType_PWM: nUsageReporting_tResourceType = 29;
pub const nUsageReporting_tResourceType_kResourceType_Relay: nUsageReporting_tResourceType = 30;
pub const nUsageReporting_tResourceType_kResourceType_RobotDrive: nUsageReporting_tResourceType =
    31;
pub const nUsageReporting_tResourceType_kResourceType_SerialPort: nUsageReporting_tResourceType =
    32;
pub const nUsageReporting_tResourceType_kResourceType_Servo: nUsageReporting_tResourceType = 33;
pub const nUsageReporting_tResourceType_kResourceType_Solenoid: nUsageReporting_tResourceType = 34;
pub const nUsageReporting_tResourceType_kResourceType_SPI: nUsageReporting_tResourceType = 35;
pub const nUsageReporting_tResourceType_kResourceType_Task: nUsageReporting_tResourceType = 36;
pub const nUsageReporting_tResourceType_kResourceType_Ultrasonic: nUsageReporting_tResourceType =
    37;
pub const nUsageReporting_tResourceType_kResourceType_Victor: nUsageReporting_tResourceType = 38;
pub const nUsageReporting_tResourceType_kResourceType_Button: nUsageReporting_tResourceType = 39;
pub const nUsageReporting_tResourceType_kResourceType_Command: nUsageReporting_tResourceType = 40;
pub const nUsageReporting_tResourceType_kResourceType_AxisCamera: nUsageReporting_tResourceType =
    41;
pub const nUsageReporting_tResourceType_kResourceType_PCVideoServer: nUsageReporting_tResourceType =
    42;
pub const nUsageReporting_tResourceType_kResourceType_SmartDashboard:
    nUsageReporting_tResourceType = 43;
pub const nUsageReporting_tResourceType_kResourceType_Talon: nUsageReporting_tResourceType = 44;
pub const nUsageReporting_tResourceType_kResourceType_HiTechnicColorSensor:
    nUsageReporting_tResourceType = 45;
pub const nUsageReporting_tResourceType_kResourceType_HiTechnicAccel:
    nUsageReporting_tResourceType = 46;
pub const nUsageReporting_tResourceType_kResourceType_HiTechnicCompass:
    nUsageReporting_tResourceType = 47;
pub const nUsageReporting_tResourceType_kResourceType_SRF08: nUsageReporting_tResourceType = 48;
pub const nUsageReporting_tResourceType_kResourceType_AnalogOutput: nUsageReporting_tResourceType =
    49;
pub const nUsageReporting_tResourceType_kResourceType_VictorSP: nUsageReporting_tResourceType = 50;
pub const nUsageReporting_tResourceType_kResourceType_PWMTalonSRX: nUsageReporting_tResourceType =
    51;
pub const nUsageReporting_tResourceType_kResourceType_CANTalonSRX: nUsageReporting_tResourceType =
    52;
pub const nUsageReporting_tResourceType_kResourceType_ADXL362: nUsageReporting_tResourceType = 53;
pub const nUsageReporting_tResourceType_kResourceType_ADXRS450: nUsageReporting_tResourceType = 54;
pub const nUsageReporting_tResourceType_kResourceType_RevSPARK: nUsageReporting_tResourceType = 55;
pub const nUsageReporting_tResourceType_kResourceType_MindsensorsSD540:
    nUsageReporting_tResourceType = 56;
pub const nUsageReporting_tResourceType_kResourceType_DigitalGlitchFilter:
    nUsageReporting_tResourceType = 57;
pub const nUsageReporting_tResourceType_kResourceType_ADIS16448: nUsageReporting_tResourceType = 58;
pub const nUsageReporting_tResourceType_kResourceType_PDP: nUsageReporting_tResourceType = 59;
pub const nUsageReporting_tResourceType_kResourceType_PCM: nUsageReporting_tResourceType = 60;
pub const nUsageReporting_tResourceType_kResourceType_PigeonIMU: nUsageReporting_tResourceType = 61;
pub const nUsageReporting_tResourceType_kResourceType_NidecBrushless:
    nUsageReporting_tResourceType = 62;
pub const nUsageReporting_tResourceType_kResourceType_CANifier: nUsageReporting_tResourceType = 63;
pub const nUsageReporting_tResourceType_kResourceType_TalonFX: nUsageReporting_tResourceType = 64;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future1: nUsageReporting_tResourceType =
    65;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future2: nUsageReporting_tResourceType =
    66;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future3: nUsageReporting_tResourceType =
    67;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future4: nUsageReporting_tResourceType =
    68;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future5: nUsageReporting_tResourceType =
    69;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future6: nUsageReporting_tResourceType =
    70;
pub const nUsageReporting_tResourceType_kResourceType_LinearFilter: nUsageReporting_tResourceType =
    71;
pub const nUsageReporting_tResourceType_kResourceType_XboxController:
    nUsageReporting_tResourceType = 72;
pub const nUsageReporting_tResourceType_kResourceType_UsbCamera: nUsageReporting_tResourceType = 73;
pub const nUsageReporting_tResourceType_kResourceType_NavX: nUsageReporting_tResourceType = 74;
pub const nUsageReporting_tResourceType_kResourceType_Pixy: nUsageReporting_tResourceType = 75;
pub const nUsageReporting_tResourceType_kResourceType_Pixy2: nUsageReporting_tResourceType = 76;
pub const nUsageReporting_tResourceType_kResourceType_ScanseSweep: nUsageReporting_tResourceType =
    77;
pub const nUsageReporting_tResourceType_kResourceType_Shuffleboard: nUsageReporting_tResourceType =
    78;
pub const nUsageReporting_tResourceType_kResourceType_CAN: nUsageReporting_tResourceType = 79;
pub const nUsageReporting_tResourceType_kResourceType_DigilentDMC60: nUsageReporting_tResourceType =
    80;
pub const nUsageReporting_tResourceType_kResourceType_PWMVictorSPX: nUsageReporting_tResourceType =
    81;
pub const nUsageReporting_tResourceType_kResourceType_RevSparkMaxPWM:
    nUsageReporting_tResourceType = 82;
pub const nUsageReporting_tResourceType_kResourceType_RevSparkMaxCAN:
    nUsageReporting_tResourceType = 83;
pub const nUsageReporting_tResourceType_kResourceType_ADIS16470: nUsageReporting_tResourceType = 84;
pub const nUsageReporting_tResourceType_kResourceType_PIDController2:
    nUsageReporting_tResourceType = 85;
pub const nUsageReporting_tResourceType_kResourceType_ProfiledPIDController:
    nUsageReporting_tResourceType = 86;
pub const nUsageReporting_tResourceType_kResourceType_Kinematics: nUsageReporting_tResourceType =
    87;
pub const nUsageReporting_tResourceType_kResourceType_Odometry: nUsageReporting_tResourceType = 88;
pub const nUsageReporting_tResourceType_kResourceType_Units: nUsageReporting_tResourceType = 89;
pub const nUsageReporting_tResourceType_kResourceType_TrapezoidProfile:
    nUsageReporting_tResourceType = 90;
pub const nUsageReporting_tResourceType_kResourceType_DutyCycle: nUsageReporting_tResourceType = 91;
pub const nUsageReporting_tResourceType_kResourceType_AddressableLEDs:
    nUsageReporting_tResourceType = 92;
pub const nUsageReporting_tResourceType_kResourceType_FusionVenom: nUsageReporting_tResourceType =
    93;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future7: nUsageReporting_tResourceType =
    94;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future8: nUsageReporting_tResourceType =
    95;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future9: nUsageReporting_tResourceType =
    96;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future10: nUsageReporting_tResourceType =
    97;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future11: nUsageReporting_tResourceType =
    98;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future12: nUsageReporting_tResourceType =
    99;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future13: nUsageReporting_tResourceType =
    100;
pub const nUsageReporting_tResourceType_kResourceType_CTRE_future14: nUsageReporting_tResourceType =
    101;
pub const nUsageReporting_tResourceType_kResourceType_ExponentialProfile:
    nUsageReporting_tResourceType = 102;
pub const nUsageReporting_tResourceType_kResourceType_PS4Controller: nUsageReporting_tResourceType =
    103;
pub const nUsageReporting_tResourceType_kResourceType_PhotonCamera: nUsageReporting_tResourceType =
    104;
pub const nUsageReporting_tResourceType_kResourceType_PhotonPoseEstimator:
    nUsageReporting_tResourceType = 105;
pub const nUsageReporting_tResourceType_kResourceType_PathPlannerPath:
    nUsageReporting_tResourceType = 106;
pub const nUsageReporting_tResourceType_kResourceType_PathPlannerAuto:
    nUsageReporting_tResourceType = 107;
pub const nUsageReporting_tResourceType_kResourceType_PathFindingCommand:
    nUsageReporting_tResourceType = 108;
pub const nUsageReporting_tResourceType_kResourceType_Redux_future1: nUsageReporting_tResourceType =
    109;
pub const nUsageReporting_tResourceType_kResourceType_Redux_future2: nUsageReporting_tResourceType =
    110;
pub const nUsageReporting_tResourceType_kResourceType_Redux_future3: nUsageReporting_tResourceType =
    111;
pub const nUsageReporting_tResourceType_kResourceType_Redux_future4: nUsageReporting_tResourceType =
    112;
pub const nUsageReporting_tResourceType_kResourceType_Redux_future5: nUsageReporting_tResourceType =
    113;
pub const nUsageReporting_tResourceType_kResourceType_RevSparkFlexCAN:
    nUsageReporting_tResourceType = 114;
pub const nUsageReporting_tResourceType_kResourceType_RevSparkFlexPWM:
    nUsageReporting_tResourceType = 115;
pub type nUsageReporting_tResourceType = ::std::os::raw::c_uint;
pub const nUsageReporting_tInstances_kLanguage_LabVIEW: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kLanguage_CPlusPlus: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kLanguage_Java: nUsageReporting_tInstances = 3;
pub const nUsageReporting_tInstances_kLanguage_Python: nUsageReporting_tInstances = 4;
pub const nUsageReporting_tInstances_kLanguage_DotNet: nUsageReporting_tInstances = 5;
pub const nUsageReporting_tInstances_kLanguage_Kotlin: nUsageReporting_tInstances = 6;
pub const nUsageReporting_tInstances_kCANPlugin_BlackJagBridge: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kCANPlugin_2CAN: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kFramework_Iterative: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kFramework_Simple: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kFramework_CommandControl: nUsageReporting_tInstances = 3;
pub const nUsageReporting_tInstances_kFramework_Timed: nUsageReporting_tInstances = 4;
pub const nUsageReporting_tInstances_kFramework_ROS: nUsageReporting_tInstances = 5;
pub const nUsageReporting_tInstances_kFramework_RobotBuilder: nUsageReporting_tInstances = 6;
pub const nUsageReporting_tInstances_kFramework_AdvantageKit: nUsageReporting_tInstances = 7;
pub const nUsageReporting_tInstances_kRobotDrive_ArcadeStandard: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kRobotDrive_ArcadeButtonSpin: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kRobotDrive_ArcadeRatioCurve: nUsageReporting_tInstances = 3;
pub const nUsageReporting_tInstances_kRobotDrive_Tank: nUsageReporting_tInstances = 4;
pub const nUsageReporting_tInstances_kRobotDrive_MecanumPolar: nUsageReporting_tInstances = 5;
pub const nUsageReporting_tInstances_kRobotDrive_MecanumCartesian: nUsageReporting_tInstances = 6;
pub const nUsageReporting_tInstances_kRobotDrive2_DifferentialArcade: nUsageReporting_tInstances =
    7;
pub const nUsageReporting_tInstances_kRobotDrive2_DifferentialTank: nUsageReporting_tInstances = 8;
pub const nUsageReporting_tInstances_kRobotDrive2_DifferentialCurvature:
    nUsageReporting_tInstances = 9;
pub const nUsageReporting_tInstances_kRobotDrive2_MecanumCartesian: nUsageReporting_tInstances = 10;
pub const nUsageReporting_tInstances_kRobotDrive2_MecanumPolar: nUsageReporting_tInstances = 11;
pub const nUsageReporting_tInstances_kRobotDrive2_KilloughCartesian: nUsageReporting_tInstances =
    12;
pub const nUsageReporting_tInstances_kRobotDrive2_KilloughPolar: nUsageReporting_tInstances = 13;
pub const nUsageReporting_tInstances_kDriverStationCIO_Analog: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kDriverStationCIO_DigitalIn: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kDriverStationCIO_DigitalOut: nUsageReporting_tInstances = 3;
pub const nUsageReporting_tInstances_kDriverStationEIO_Acceleration: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kDriverStationEIO_AnalogIn: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kDriverStationEIO_AnalogOut: nUsageReporting_tInstances = 3;
pub const nUsageReporting_tInstances_kDriverStationEIO_Button: nUsageReporting_tInstances = 4;
pub const nUsageReporting_tInstances_kDriverStationEIO_LED: nUsageReporting_tInstances = 5;
pub const nUsageReporting_tInstances_kDriverStationEIO_DigitalIn: nUsageReporting_tInstances = 6;
pub const nUsageReporting_tInstances_kDriverStationEIO_DigitalOut: nUsageReporting_tInstances = 7;
pub const nUsageReporting_tInstances_kDriverStationEIO_FixedDigitalOut: nUsageReporting_tInstances =
    8;
pub const nUsageReporting_tInstances_kDriverStationEIO_PWM: nUsageReporting_tInstances = 9;
pub const nUsageReporting_tInstances_kDriverStationEIO_Encoder: nUsageReporting_tInstances = 10;
pub const nUsageReporting_tInstances_kDriverStationEIO_TouchSlider: nUsageReporting_tInstances = 11;
pub const nUsageReporting_tInstances_kADXL345_SPI: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kADXL345_I2C: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kCommand_Scheduler: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kCommand2_Scheduler: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kSmartDashboard_Instance: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kKinematics_DifferentialDrive: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kKinematics_MecanumDrive: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kKinematics_SwerveDrive: nUsageReporting_tInstances = 3;
pub const nUsageReporting_tInstances_kOdometry_DifferentialDrive: nUsageReporting_tInstances = 1;
pub const nUsageReporting_tInstances_kOdometry_MecanumDrive: nUsageReporting_tInstances = 2;
pub const nUsageReporting_tInstances_kOdometry_SwerveDrive: nUsageReporting_tInstances = 3;
pub type nUsageReporting_tInstances = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Report the usage of a resource of interest.\n\n @param resource one of the values in the tResourceType above (max value 51).\n @param instanceNumber an index that identifies the resource instance.\n @param context an optional additional context number for some cases (such as module number).  Set to 0 to omit.\n @param feature a string to be included describing features in use on a specific resource.  Setting the same resource more than once allows you to change the feature string."]
    #[link_name = "\u{1}_ZN15nUsageReporting6reportENS_13tResourceTypeEhhPKc"]
    pub fn nUsageReporting_report(
        resource: nUsageReporting_tResourceType,
        instanceNumber: u8,
        context: u8,
        feature: *const ::std::os::raw::c_char,
    ) -> u32;
}
extern "C" {
    pub fn FRC_NetworkCommunication_nUsageReporting_report(
        resource: u8,
        instanceNumber: u8,
        context: u8,
        feature: *const ::std::os::raw::c_char,
    ) -> u32;
}
