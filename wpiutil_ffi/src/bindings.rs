/* automatically generated by rust-bindgen 0.65.1 */

#[doc = " Generic handle for all WPI handle-based interfaces.\n\n Handle data layout:\n - Bits 0-23:  Type-specific\n - Bits 24-30: Type\n - Bit 31:     Error"]
pub type WPI_Handle = ::std::os::raw::c_uint;
#[doc = " An event handle."]
pub type WPI_EventHandle = WPI_Handle;
#[doc = " A semaphore handle."]
pub type WPI_SemaphoreHandle = WPI_Handle;
extern "C" {
    #[doc = " Creates an event.  Events have binary state (signaled or not signaled) and\n may be either automatically reset or manually reset.  Automatic-reset events\n go to non-signaled state when a WaitForObject is woken up by the event;\n manual-reset events require ResetEvent() to be called to set the event to\n non-signaled state; if ResetEvent() is not called, any waiter on that event\n will immediately wake when called.\n\n @param manual_reset true for manual reset, false for automatic reset\n @param initial_state true to make the event initially in signaled state\n @return Event handle"]
    pub fn WPI_CreateEvent(
        manual_reset: ::std::os::raw::c_int,
        initial_state: ::std::os::raw::c_int,
    ) -> WPI_EventHandle;
}
extern "C" {
    #[doc = " Destroys an event.  Destruction wakes up any waiters.\n\n @param handle event handle"]
    pub fn WPI_DestroyEvent(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Sets an event to signaled state.\n\n @param handle event handle"]
    pub fn WPI_SetEvent(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Sets an event to non-signaled state.\n\n @param handle event handle"]
    pub fn WPI_ResetEvent(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Creates a semaphore.  Semaphores keep an internal counter.  Releasing the\n semaphore increases the count.  A semaphore with a non-zero count is\n considered signaled.  When a waiter wakes up it atomically decrements the\n count by 1.  This is generally useful in a single-supplier,\n multiple-consumer scenario.\n\n @param initial_count initial value for the semaphore's internal counter\n @param maximum_count maximum value for the samephore's internal counter\n @return Semaphore handle"]
    pub fn WPI_CreateSemaphore(
        initial_count: ::std::os::raw::c_int,
        maximum_count: ::std::os::raw::c_int,
    ) -> WPI_SemaphoreHandle;
}
extern "C" {
    #[doc = " Destroys a semaphore.  Destruction wakes up any waiters.\n\n @param handle semaphore handle"]
    pub fn WPI_DestroySemaphore(handle: WPI_SemaphoreHandle);
}
extern "C" {
    #[doc = " Releases N counts of a semaphore.\n\n @param handle semaphore handle\n @param release_count amount to add to semaphore's internal counter;\n        must be positive\n @param prev_count if non-null, previous count (output parameter)\n @return Non-zero on successful release, zero on failure (e.g. release count\n         would exceed maximum value, or handle invalid)"]
    pub fn WPI_ReleaseSemaphore(
        handle: WPI_SemaphoreHandle,
        release_count: ::std::os::raw::c_int,
        prev_count: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for an handle to be signaled.\n\n @param handle handle to wait on\n @return Non-zero if handle was signaled, zero otherwise (e.g. object was\n         destroyed)"]
    pub fn WPI_WaitForObject(handle: WPI_Handle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for an handle to be signaled, with timeout.\n\n @param handle handle to wait on\n @param timeout timeout in seconds\n @param timed_out if non-null, set to non-zero if timeout reached without\n        handle being signaled; set to zero otherwise (output)\n @return Non-zero if handle was signaled, zero otherwise (e.g. object was\n         destroyed or timed out)"]
    pub fn WPI_WaitForObjectTimeout(
        handle: WPI_Handle,
        timeout: f64,
        timed_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for one or more handles to be signaled.\n\n Invalid handles are treated as signaled; the returned array will have the\n handle error bit set for any invalid handles.\n\n @param handles array of handles to wait on\n @param handles_count length of the handles array\n @param signaled output array for storage of signaled handles; must be at\n        least the size of the handles input array\n @return number of signaled handles"]
    pub fn WPI_WaitForObjects(
        handles: *const WPI_Handle,
        handles_count: ::std::os::raw::c_int,
        signaled: *mut WPI_Handle,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Waits for one or more handles to be signaled, with timeout.\n\n Invalid handles are treated as signaled; the returned array will have the\n handle error bit set for any invalid handles.\n\n @param handles array of handles to wait on\n @param handles_count length of the handles array\n @param signaled output array for storage of signaled handles; must be at\n        least the size of the handles input array\n @param timeout timeout in seconds\n @param timed_out if non-null, set to non-zero if timeout reached without any\n        handle being signaled; set to zero otherwise (output)\n @return number of signaled handles"]
    pub fn WPI_WaitForObjectsTimeout(
        handles: *const WPI_Handle,
        handles_count: ::std::os::raw::c_int,
        signaled: *mut WPI_Handle,
        timeout: f64,
        timed_out: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets up signaling for an arbitrary handle.  With this function, any handle\n can operate like an event handle.\n\n @param handle handle\n @param manual_reset true for manual reset, false for automatic reset\n @param initial_state true to make the handle initially in signaled state"]
    pub fn WPI_CreateSignalObject(
        handle: WPI_Handle,
        manual_reset: ::std::os::raw::c_int,
        initial_state: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets a handle to signaled state.\n\n @param handle handle"]
    pub fn WPI_SetSignalObject(handle: WPI_Handle);
}
extern "C" {
    #[doc = " Sets a handle to non-signaled state.\n\n @param handle handle"]
    pub fn WPI_ResetSignalObject(handle: WPI_Handle);
}
extern "C" {
    #[doc = " Cleans up signaling for a handle.  Destruction wakes up any waiters.\n\n @param handle handle"]
    pub fn WPI_DestroySignalObject(handle: WPI_Handle);
}
