/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const HAL_kInvalidHandle: u32 = 0;
pub const HAL_CAN_SEND_PERIOD_NO_REPEAT: u32 = 0;
pub const HAL_CAN_SEND_PERIOD_STOP_REPEATING: i32 = -1;
pub const HAL_CAN_IS_FRAME_REMOTE: u32 = 2147483648;
pub const HAL_CAN_IS_FRAME_11BIT: u32 = 1073741824;
pub const HAL_ERR_CANSessionMux_InvalidBuffer: i32 = -44086;
pub const HAL_ERR_CANSessionMux_MessageNotFound: i32 = -44087;
pub const HAL_WARN_CANSessionMux_NoToken: u32 = 44087;
pub const HAL_ERR_CANSessionMux_NotAllowed: i32 = -44088;
pub const HAL_ERR_CANSessionMux_NotInitialized: i32 = -44089;
pub const HAL_ERR_CANSessionMux_SessionOverrun: u32 = 44050;
pub const HAL_IO_CONFIG_DATA_SIZE: u32 = 32;
pub const HAL_SYS_STATUS_DATA_SIZE: u32 = 44;
pub const HAL_USER_STATUS_DATA_SIZE: u32 = 908;
pub const HAL_kMaxJoystickAxes: u32 = 12;
pub const HAL_kMaxJoystickPOVs: u32 = 12;
pub const HAL_kMaxJoysticks: u32 = 6;
pub const HAL_SUCCESS: u32 = 0;
pub const HAL_INVALID_ACCUMULATOR_CHANNEL: i32 = -1035;
pub const HAL_INVALID_ACCUMULATOR_CHANNEL_MESSAGE: &[u8; 55usize] =
    b"HAL: The requested input is not an accumulator channel\0";
pub const HAL_COUNTER_NOT_SUPPORTED: i32 = -1058;
pub const HAL_COUNTER_NOT_SUPPORTED_MESSAGE: &[u8; 51usize] =
    b"HAL: Counter mode not supported for encoder method\0";
pub const HAL_PWM_SCALE_ERROR: i32 = -1072;
pub const HAL_PWM_SCALE_ERROR_MESSAGE: &[u8; 44usize] =
    b"HAL: The PWM Scale Factors are out of range\0";
pub const HAL_HANDLE_ERROR: i32 = -1098;
pub const HAL_HANDLE_ERROR_MESSAGE: &[u8; 47usize] =
    b"HAL: A handle parameter was passed incorrectly\0";
pub const HAL_LED_CHANNEL_ERROR: i32 = -1099;
pub const HAL_LED_CHANNEL_ERROR_MESSAGE: &[u8; 68usize] =
    b"HAL: Addressable LEDs only supported on PWM Headers, not MXP or DIO\0";
pub const HAL_INVALID_DMA_ADDITION: i32 = -1102;
pub const HAL_INVALID_DMA_ADDITION_MESSAGE: &[u8; 46usize] =
    b"HAL_AddDMA() only works before HAL_StartDMA()\0";
pub const HAL_INVALID_DMA_STATE: i32 = -1103;
pub const HAL_INVALID_DMA_STATE_MESSAGE: &[u8; 48usize] =
    b"HAL_SetPause() only works before HAL_StartDMA()\0";
pub const HAL_SERIAL_PORT_NOT_FOUND: i32 = -1123;
pub const HAL_SERIAL_PORT_NOT_FOUND_MESSAGE: &[u8; 52usize] =
    b"HAL: The specified serial port device was not found\0";
pub const HAL_SERIAL_PORT_OPEN_ERROR: i32 = -1124;
pub const HAL_SERIAL_PORT_OPEN_ERROR_MESSAGE: &[u8; 41usize] =
    b"HAL: The serial port could not be opened\0";
pub const HAL_SERIAL_PORT_ERROR: i32 = -1125;
pub const HAL_SERIAL_PORT_ERROR_MESSAGE: &[u8; 43usize] =
    b"HAL: There was an error on the serial port\0";
pub const HAL_THREAD_PRIORITY_ERROR: i32 = -1152;
pub const HAL_THREAD_PRIORITY_ERROR_MESSAGE: &[u8; 60usize] =
    b"HAL: Getting or setting the priority of a thread has failed\0";
pub const HAL_THREAD_PRIORITY_RANGE_ERROR: i32 = -1153;
pub const HAL_THREAD_PRIORITY_RANGE_ERROR_MESSAGE: &[u8; 49usize] =
    b"HAL: The priority requested to be set is invalid\0";
pub const HAL_CAN_TIMEOUT: i32 = -1154;
pub const HAL_CAN_TIMEOUT_MESSAGE: &[u8; 31usize] = b"HAL: CAN Receive has Timed Out\0";
pub const HAL_SIM_NOT_SUPPORTED: i32 = -1155;
pub const HAL_SIM_NOT_SUPPORTED_MESSAGE: &[u8; 33usize] = b"HAL: Method not supported in sim\0";
pub const HAL_USE_LAST_ERROR: i32 = -1156;
pub const HAL_USE_LAST_ERROR_MESSAGE: &[u8; 52usize] =
    b"HAL: Use HAL_GetLastError(status) to get last error\0";
pub const HAL_CONSOLE_OUT_ENABLED_ERROR: i32 = -1157;
pub const HAL_CONSOLE_OUT_ENABLED_ERROR_MESSAGE : & [u8 ; 106usize] = b"HAL: Onboard serial port is requested, but Console Out is enabled. Disable Console Out using imaging tool\0" ;
pub const HAL_CAN_BUFFER_OVERRUN: i32 = -35007;
pub const HAL_CAN_BUFFER_OVERRUN_MESSAGE: &[u8; 57usize] =
    b"HAL: CAN Output Buffer Full. Ensure a device is attached\0";
pub type HAL_Handle = i32;
pub type HAL_PortHandle = HAL_Handle;
pub type HAL_AnalogInputHandle = HAL_Handle;
pub type HAL_AnalogOutputHandle = HAL_Handle;
pub type HAL_AnalogTriggerHandle = HAL_Handle;
pub type HAL_CompressorHandle = HAL_Handle;
pub type HAL_CounterHandle = HAL_Handle;
pub type HAL_DigitalHandle = HAL_Handle;
pub type HAL_DigitalPWMHandle = HAL_Handle;
pub type HAL_EncoderHandle = HAL_Handle;
pub type HAL_FPGAEncoderHandle = HAL_Handle;
pub type HAL_GyroHandle = HAL_Handle;
pub type HAL_InterruptHandle = HAL_Handle;
pub type HAL_NotifierHandle = HAL_Handle;
pub type HAL_RelayHandle = HAL_Handle;
pub type HAL_SolenoidHandle = HAL_Handle;
pub type HAL_SerialPortHandle = HAL_Handle;
pub type HAL_CANHandle = HAL_Handle;
pub type HAL_SimDeviceHandle = HAL_Handle;
pub type HAL_SimValueHandle = HAL_Handle;
pub type HAL_DMAHandle = HAL_Handle;
pub type HAL_DutyCycleHandle = HAL_Handle;
pub type HAL_AddressableLEDHandle = HAL_Handle;
pub type HAL_PDPHandle = HAL_CANHandle;
pub type HAL_PowerDistributionHandle = HAL_Handle;
pub type HAL_CTREPCMHandle = HAL_Handle;
pub type HAL_REVPDHHandle = HAL_Handle;
pub type HAL_REVPHHandle = HAL_Handle;
pub type HAL_Bool = i32;
pub const HAL_AccelerometerRange_HAL_AccelerometerRange_k2G: HAL_AccelerometerRange = 0;
pub const HAL_AccelerometerRange_HAL_AccelerometerRange_k4G: HAL_AccelerometerRange = 1;
pub const HAL_AccelerometerRange_HAL_AccelerometerRange_k8G: HAL_AccelerometerRange = 2;
pub type HAL_AccelerometerRange = i32;
extern "C" {
    pub fn HAL_SetAccelerometerActive(active: HAL_Bool);
}
extern "C" {
    pub fn HAL_SetAccelerometerRange(range: HAL_AccelerometerRange);
}
extern "C" {
    pub fn HAL_GetAccelerometerX() -> f64;
}
extern "C" {
    pub fn HAL_GetAccelerometerY() -> f64;
}
extern "C" {
    pub fn HAL_GetAccelerometerZ() -> f64;
}
extern "C" {
    pub fn HAL_IsAccumulatorChannel(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_InitAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_ResetAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAccumulatorCenter(
        analogPortHandle: HAL_AnalogInputHandle,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAccumulatorDeadband(
        analogPortHandle: HAL_AnalogInputHandle,
        deadband: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetAccumulatorValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    pub fn HAL_GetAccumulatorCount(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    pub fn HAL_GetAccumulatorOutput(
        analogPortHandle: HAL_AnalogInputHandle,
        value: *mut i64,
        count: *mut i64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_InitializeAnalogGyro(
        handle: HAL_AnalogInputHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_GyroHandle;
}
extern "C" {
    pub fn HAL_SetupAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_FreeAnalogGyro(handle: HAL_GyroHandle);
}
extern "C" {
    pub fn HAL_SetAnalogGyroParameters(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        offset: f64,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAnalogGyroVoltsPerDegreePerSecond(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ResetAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_CalibrateAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAnalogGyroDeadband(handle: HAL_GyroHandle, volts: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetAnalogGyroAngle(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogGyroRate(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogGyroOffset(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogGyroCenter(handle: HAL_GyroHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_InitializeAnalogInputPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_AnalogInputHandle;
}
extern "C" {
    pub fn HAL_FreeAnalogInputPort(analogPortHandle: HAL_AnalogInputHandle);
}
extern "C" {
    pub fn HAL_CheckAnalogModule(module: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_CheckAnalogInputChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetAnalogInputSimDevice(handle: HAL_AnalogInputHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    pub fn HAL_SetAnalogSampleRate(samplesPerSecond: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetAnalogSampleRate(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_SetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_SetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogValue(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogAverageValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogVoltsToValue(
        analogPortHandle: HAL_AnalogInputHandle,
        voltage: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogVoltage(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogAverageVoltage(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn HAL_GetAnalogLSBWeight(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32)
        -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogOffset(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetAnalogValueToVolts(
        analogPortHandle: HAL_AnalogInputHandle,
        rawValue: i32,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn HAL_InitializeAnalogOutputPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_AnalogOutputHandle;
}
extern "C" {
    pub fn HAL_FreeAnalogOutputPort(analogOutputHandle: HAL_AnalogOutputHandle);
}
extern "C" {
    pub fn HAL_SetAnalogOutput(
        analogOutputHandle: HAL_AnalogOutputHandle,
        voltage: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetAnalogOutput(analogOutputHandle: HAL_AnalogOutputHandle, status: *mut i32)
        -> f64;
}
extern "C" {
    pub fn HAL_CheckAnalogOutputChannel(channel: i32) -> HAL_Bool;
}
pub const HAL_AnalogTriggerType_HAL_Trigger_kInWindow: HAL_AnalogTriggerType = 0;
pub const HAL_AnalogTriggerType_HAL_Trigger_kState: HAL_AnalogTriggerType = 1;
pub const HAL_AnalogTriggerType_HAL_Trigger_kRisingPulse: HAL_AnalogTriggerType = 2;
pub const HAL_AnalogTriggerType_HAL_Trigger_kFallingPulse: HAL_AnalogTriggerType = 3;
pub type HAL_AnalogTriggerType = i32;
extern "C" {
    pub fn HAL_InitializeAnalogTrigger(
        portHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    pub fn HAL_InitializeAnalogTriggerDutyCycle(
        dutyCycleHandle: HAL_DutyCycleHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    pub fn HAL_CleanAnalogTrigger(analogTriggerHandle: HAL_AnalogTriggerHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetAnalogTriggerLimitsRaw(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: i32,
        upper: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAnalogTriggerLimitsVoltage(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAnalogTriggerLimitsDutyCycle(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAnalogTriggerAveraged(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useAveragedValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAnalogTriggerFiltered(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useFilteredValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetAnalogTriggerInWindow(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetAnalogTriggerTriggerState(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetAnalogTriggerOutput(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        type_: HAL_AnalogTriggerType,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetAnalogTriggerFPGAIndex(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_CANStreamMessage {
    pub messageID: u32,
    pub timeStamp: u32,
    pub data: [u8; 8usize],
    pub dataSize: u8,
}
#[test]
fn bindgen_test_layout_HAL_CANStreamMessage() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_CANStreamMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_CANStreamMessage>(),
        20usize,
        concat!("Size of: ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_CANStreamMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(messageID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(dataSize)
        )
    );
}
extern "C" {
    pub fn HAL_CAN_SendMessage(
        messageID: u32,
        data: *const u8,
        dataSize: u8,
        periodMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_CAN_ReceiveMessage(
        messageID: *mut u32,
        messageIDMask: u32,
        data: *mut u8,
        dataSize: *mut u8,
        timeStamp: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_CAN_OpenStreamSession(
        sessionHandle: *mut u32,
        messageID: u32,
        messageIDMask: u32,
        maxMessages: u32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_CAN_CloseStreamSession(sessionHandle: u32);
}
extern "C" {
    pub fn HAL_CAN_ReadStreamSession(
        sessionHandle: u32,
        messages: *mut HAL_CANStreamMessage,
        messagesToRead: u32,
        messagesRead: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_CAN_GetCANStatus(
        percentBusUtilization: *mut f32,
        busOffCount: *mut u32,
        txFullCount: *mut u32,
        receiveErrorCount: *mut u32,
        transmitErrorCount: *mut u32,
        status: *mut i32,
    );
}
pub const HAL_CANDeviceType_HAL_CAN_Dev_kBroadcast: HAL_CANDeviceType = 0;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kRobotController: HAL_CANDeviceType = 1;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kMotorController: HAL_CANDeviceType = 2;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kRelayController: HAL_CANDeviceType = 3;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kGyroSensor: HAL_CANDeviceType = 4;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kAccelerometer: HAL_CANDeviceType = 5;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kUltrasonicSensor: HAL_CANDeviceType = 6;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kGearToothSensor: HAL_CANDeviceType = 7;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kPowerDistribution: HAL_CANDeviceType = 8;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kPneumatics: HAL_CANDeviceType = 9;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kMiscellaneous: HAL_CANDeviceType = 10;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kIOBreakout: HAL_CANDeviceType = 11;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kFirmwareUpdate: HAL_CANDeviceType = 31;
pub type HAL_CANDeviceType = i32;
pub const HAL_CANManufacturer_HAL_CAN_Man_kBroadcast: HAL_CANManufacturer = 0;
pub const HAL_CANManufacturer_HAL_CAN_Man_kNI: HAL_CANManufacturer = 1;
pub const HAL_CANManufacturer_HAL_CAN_Man_kLM: HAL_CANManufacturer = 2;
pub const HAL_CANManufacturer_HAL_CAN_Man_kDEKA: HAL_CANManufacturer = 3;
pub const HAL_CANManufacturer_HAL_CAN_Man_kCTRE: HAL_CANManufacturer = 4;
pub const HAL_CANManufacturer_HAL_CAN_Man_kREV: HAL_CANManufacturer = 5;
pub const HAL_CANManufacturer_HAL_CAN_Man_kGrapple: HAL_CANManufacturer = 6;
pub const HAL_CANManufacturer_HAL_CAN_Man_kMS: HAL_CANManufacturer = 7;
pub const HAL_CANManufacturer_HAL_CAN_Man_kTeamUse: HAL_CANManufacturer = 8;
pub const HAL_CANManufacturer_HAL_CAN_Man_kKauaiLabs: HAL_CANManufacturer = 9;
pub const HAL_CANManufacturer_HAL_CAN_Man_kCopperforge: HAL_CANManufacturer = 10;
pub const HAL_CANManufacturer_HAL_CAN_Man_kPWF: HAL_CANManufacturer = 11;
pub const HAL_CANManufacturer_HAL_CAN_Man_kStudica: HAL_CANManufacturer = 12;
pub const HAL_CANManufacturer_HAL_CAN_Man_kTheThriftyBot: HAL_CANManufacturer = 13;
pub type HAL_CANManufacturer = i32;
extern "C" {
    pub fn HAL_InitializeCAN(
        manufacturer: HAL_CANManufacturer,
        deviceId: i32,
        deviceType: HAL_CANDeviceType,
        status: *mut i32,
    ) -> HAL_CANHandle;
}
extern "C" {
    pub fn HAL_CleanCAN(handle: HAL_CANHandle);
}
extern "C" {
    pub fn HAL_WriteCANPacket(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_WriteCANPacketRepeating(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        repeatMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_WriteCANRTRFrame(handle: HAL_CANHandle, length: i32, apiId: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_StopCANPacketRepeating(handle: HAL_CANHandle, apiId: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_ReadCANPacketNew(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ReadCANPacketLatest(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ReadCANPacketTimeout(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        timeoutMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_InitializeCTREPCM(
        module: i32,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_CTREPCMHandle;
}
extern "C" {
    pub fn HAL_FreeCTREPCM(handle: HAL_CTREPCMHandle);
}
extern "C" {
    pub fn HAL_CheckCTREPCMSolenoidChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressor(handle: HAL_CTREPCMHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetCTREPCMClosedLoopControl(
        handle: HAL_CTREPCMHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetCTREPCMClosedLoopControl(handle: HAL_CTREPCMHandle, status: *mut i32)
        -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMPressureSwitch(handle: HAL_CTREPCMHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorCurrent(handle: HAL_CTREPCMHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorCurrentTooHighFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorCurrentTooHighStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorShortedStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorShortedFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorNotConnectedStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorNotConnectedFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMSolenoids(handle: HAL_CTREPCMHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetCTREPCMSolenoids(
        handle: HAL_CTREPCMHandle,
        mask: i32,
        values: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetCTREPCMSolenoidDisabledList(handle: HAL_CTREPCMHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetCTREPCMSolenoidVoltageStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMSolenoidVoltageFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_ClearAllCTREPCMStickyFaults(handle: HAL_CTREPCMHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_FireCTREPCMOneShot(handle: HAL_CTREPCMHandle, index: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCTREPCMOneShotDuration(
        handle: HAL_CTREPCMHandle,
        index: i32,
        durMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetSystemClockTicksPerMicrosecond() -> i32;
}
pub const HAL_Counter_Mode_HAL_Counter_kTwoPulse: HAL_Counter_Mode = 0;
pub const HAL_Counter_Mode_HAL_Counter_kSemiperiod: HAL_Counter_Mode = 1;
pub const HAL_Counter_Mode_HAL_Counter_kPulseLength: HAL_Counter_Mode = 2;
pub const HAL_Counter_Mode_HAL_Counter_kExternalDirection: HAL_Counter_Mode = 3;
pub type HAL_Counter_Mode = i32;
extern "C" {
    pub fn HAL_InitializeCounter(
        mode: HAL_Counter_Mode,
        index: *mut i32,
        status: *mut i32,
    ) -> HAL_CounterHandle;
}
extern "C" {
    pub fn HAL_FreeCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterAverageSize(counterHandle: HAL_CounterHandle, size: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterUpSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetCounterUpSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ClearCounterUpSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterDownSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetCounterDownSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ClearCounterDownSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterUpDownMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterExternalDirectionMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCounterSemiPeriodMode(
        counterHandle: HAL_CounterHandle,
        highSemiPeriod: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetCounterPulseLengthMode(
        counterHandle: HAL_CounterHandle,
        threshold: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_SetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ResetCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetCounter(counterHandle: HAL_CounterHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetCounterPeriod(counterHandle: HAL_CounterHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_SetCounterMaxPeriod(
        counterHandle: HAL_CounterHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetCounterUpdateWhenEmpty(
        counterHandle: HAL_CounterHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetCounterStopped(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCounterDirection(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetCounterReverseDirection(
        counterHandle: HAL_CounterHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_InitializeDIOPort(
        portHandle: HAL_PortHandle,
        input: HAL_Bool,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_DigitalHandle;
}
extern "C" {
    pub fn HAL_CheckDIOChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_FreeDIOPort(dioPortHandle: HAL_DigitalHandle);
}
extern "C" {
    pub fn HAL_SetDIOSimDevice(handle: HAL_DigitalHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    pub fn HAL_AllocateDigitalPWM(status: *mut i32) -> HAL_DigitalPWMHandle;
}
extern "C" {
    pub fn HAL_FreeDigitalPWM(pwmGenerator: HAL_DigitalPWMHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetDigitalPWMRate(rate: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetDigitalPWMDutyCycle(
        pwmGenerator: HAL_DigitalPWMHandle,
        dutyCycle: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetDigitalPWMPPS(
        pwmGenerator: HAL_DigitalPWMHandle,
        dutyCycle: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetDigitalPWMOutputChannel(
        pwmGenerator: HAL_DigitalPWMHandle,
        channel: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetDIO(dioPortHandle: HAL_DigitalHandle, value: HAL_Bool, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetDIODirection(dioPortHandle: HAL_DigitalHandle, input: HAL_Bool, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetDIO(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetDIODirection(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_Pulse(dioPortHandle: HAL_DigitalHandle, pulseLengthSeconds: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_PulseMultiple(channelMask: u32, pulseLengthSeconds: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_IsPulsing(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_IsAnyPulsing(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetFilterSelect(
        dioPortHandle: HAL_DigitalHandle,
        filterIndex: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetFilterSelect(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetFilterPeriod(filterIndex: i32, value: i64, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetFilterPeriod(filterIndex: i32, status: *mut i32) -> i64;
}
pub type WPI_Handle = ::std::os::raw::c_uint;
pub type WPI_EventHandle = WPI_Handle;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HAL_ControlWord {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_HAL_ControlWord() {
    assert_eq!(
        ::std::mem::size_of::<HAL_ControlWord>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_ControlWord))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_ControlWord>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_ControlWord))
    );
}
impl HAL_ControlWord {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn test(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eStop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eStop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fmsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fmsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn control_reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_control_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: u32,
        autonomous: u32,
        test: u32,
        eStop: u32,
        fmsAttached: u32,
        dsAttached: u32,
        control_reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let test: u32 = unsafe { ::std::mem::transmute(test) };
            test as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let eStop: u32 = unsafe { ::std::mem::transmute(eStop) };
            eStop as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fmsAttached: u32 = unsafe { ::std::mem::transmute(fmsAttached) };
            fmsAttached as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsAttached: u32 = unsafe { ::std::mem::transmute(dsAttached) };
            dsAttached as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let control_reserved: u32 = unsafe { ::std::mem::transmute(control_reserved) };
            control_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed1: HAL_AllianceStationID = 0;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed2: HAL_AllianceStationID = 1;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed3: HAL_AllianceStationID = 2;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue1: HAL_AllianceStationID = 3;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue2: HAL_AllianceStationID = 4;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue3: HAL_AllianceStationID = 5;
pub type HAL_AllianceStationID = i32;
pub const HAL_MatchType_HAL_kMatchType_none: HAL_MatchType = 0;
pub const HAL_MatchType_HAL_kMatchType_practice: HAL_MatchType = 1;
pub const HAL_MatchType_HAL_kMatchType_qualification: HAL_MatchType = 2;
pub const HAL_MatchType_HAL_kMatchType_elimination: HAL_MatchType = 3;
pub type HAL_MatchType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickAxes {
    pub count: i16,
    pub axes: [f32; 12usize],
    pub raw: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickAxes() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickAxes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickAxes>(),
        64usize,
        concat!("Size of: ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickAxes>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(axes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickPOVs {
    pub count: i16,
    pub povs: [i16; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickPOVs() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickPOVs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickPOVs>(),
        26usize,
        concat!("Size of: ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickPOVs>(),
        2usize,
        concat!("Alignment of ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).povs) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(povs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickButtons {
    pub buttons: u32,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickButtons() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickButtons> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickButtons>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickButtons>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickDescriptor {
    pub isXbox: u8,
    pub type_: u8,
    pub name: [::std::os::raw::c_char; 256usize],
    pub axisCount: u8,
    pub axisTypes: [u8; 12usize],
    pub buttonCount: u8,
    pub povCount: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickDescriptor() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickDescriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickDescriptor>(),
        273usize,
        concat!("Size of: ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isXbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(isXbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axisCount) as usize - ptr as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axisTypes) as usize - ptr as usize },
        259usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttonCount) as usize - ptr as usize },
        271usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(buttonCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).povCount) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(povCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_MatchInfo {
    pub eventName: [::std::os::raw::c_char; 64usize],
    pub matchType: HAL_MatchType,
    pub matchNumber: u16,
    pub replayNumber: u8,
    pub gameSpecificMessage: [u8; 64usize],
    pub gameSpecificMessageSize: u16,
}
#[test]
fn bindgen_test_layout_HAL_MatchInfo() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_MatchInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_MatchInfo>(),
        140usize,
        concat!("Size of: ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_MatchInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(eventName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matchType) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matchNumber) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replayNumber) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(replayNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessage) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessageSize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessageSize)
        )
    );
}
extern "C" {
    pub fn HAL_SendError(
        isError: HAL_Bool,
        errorCode: i32,
        isLVCode: HAL_Bool,
        details: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
        callStack: *const ::std::os::raw::c_char,
        printMsg: HAL_Bool,
    ) -> i32;
}
extern "C" {
    pub fn HAL_SetPrintErrorImpl(
        func: ::std::option::Option<
            unsafe extern "C" fn(line: *const ::std::os::raw::c_char, size: usize),
        >,
    );
}
extern "C" {
    pub fn HAL_SendConsoleLine(line: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    pub fn HAL_GetControlWord(controlWord: *mut HAL_ControlWord) -> i32;
}
extern "C" {
    pub fn HAL_GetAllianceStation(status: *mut i32) -> HAL_AllianceStationID;
}
extern "C" {
    pub fn HAL_GetJoystickAxes(joystickNum: i32, axes: *mut HAL_JoystickAxes) -> i32;
}
extern "C" {
    pub fn HAL_GetJoystickPOVs(joystickNum: i32, povs: *mut HAL_JoystickPOVs) -> i32;
}
extern "C" {
    pub fn HAL_GetJoystickButtons(joystickNum: i32, buttons: *mut HAL_JoystickButtons) -> i32;
}
extern "C" {
    pub fn HAL_GetAllJoystickData(
        axes: *mut HAL_JoystickAxes,
        povs: *mut HAL_JoystickPOVs,
        buttons: *mut HAL_JoystickButtons,
    );
}
extern "C" {
    pub fn HAL_GetJoystickDescriptor(joystickNum: i32, desc: *mut HAL_JoystickDescriptor) -> i32;
}
extern "C" {
    pub fn HAL_GetJoystickIsXbox(joystickNum: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetJoystickType(joystickNum: i32) -> i32;
}
extern "C" {
    pub fn HAL_GetJoystickName(joystickNum: i32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn HAL_FreeJoystickName(name: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn HAL_GetJoystickAxisType(joystickNum: i32, axis: i32) -> i32;
}
extern "C" {
    pub fn HAL_SetJoystickOutputs(
        joystickNum: i32,
        outputs: i64,
        leftRumble: i32,
        rightRumble: i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_GetMatchTime(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetOutputsEnabled() -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetMatchInfo(info: *mut HAL_MatchInfo) -> i32;
}
extern "C" {
    pub fn HAL_RefreshDSData() -> HAL_Bool;
}
extern "C" {
    pub fn HAL_ProvideNewDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    pub fn HAL_RemoveNewDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    pub fn HAL_ObserveUserProgramStarting();
}
extern "C" {
    pub fn HAL_ObserveUserProgramDisabled();
}
extern "C" {
    pub fn HAL_ObserveUserProgramAutonomous();
}
extern "C" {
    pub fn HAL_ObserveUserProgramTeleop();
}
extern "C" {
    pub fn HAL_ObserveUserProgramTest();
}
pub const HAL_EncoderIndexingType_HAL_kResetWhileHigh: HAL_EncoderIndexingType = 0;
pub const HAL_EncoderIndexingType_HAL_kResetWhileLow: HAL_EncoderIndexingType = 1;
pub const HAL_EncoderIndexingType_HAL_kResetOnFallingEdge: HAL_EncoderIndexingType = 2;
pub const HAL_EncoderIndexingType_HAL_kResetOnRisingEdge: HAL_EncoderIndexingType = 3;
pub type HAL_EncoderIndexingType = i32;
pub const HAL_EncoderEncodingType_HAL_Encoder_k1X: HAL_EncoderEncodingType = 0;
pub const HAL_EncoderEncodingType_HAL_Encoder_k2X: HAL_EncoderEncodingType = 1;
pub const HAL_EncoderEncodingType_HAL_Encoder_k4X: HAL_EncoderEncodingType = 2;
pub type HAL_EncoderEncodingType = i32;
extern "C" {
    pub fn HAL_InitializeEncoder(
        digitalSourceHandleA: HAL_Handle,
        analogTriggerTypeA: HAL_AnalogTriggerType,
        digitalSourceHandleB: HAL_Handle,
        analogTriggerTypeB: HAL_AnalogTriggerType,
        reverseDirection: HAL_Bool,
        encodingType: HAL_EncoderEncodingType,
        status: *mut i32,
    ) -> HAL_EncoderHandle;
}
extern "C" {
    pub fn HAL_FreeEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetEncoderSimDevice(handle: HAL_EncoderHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    pub fn HAL_GetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetEncoderRaw(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetEncoderEncodingScale(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_ResetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetEncoderPeriod(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_SetEncoderMaxPeriod(
        encoderHandle: HAL_EncoderHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetEncoderStopped(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetEncoderDirection(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetEncoderDistance(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetEncoderRate(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_SetEncoderMinRate(encoderHandle: HAL_EncoderHandle, minRate: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        distancePerPulse: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetEncoderReverseDirection(
        encoderHandle: HAL_EncoderHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_SetEncoderIndexSource(
        encoderHandle: HAL_EncoderHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        type_: HAL_EncoderIndexingType,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetEncoderFPGAIndex(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetEncoderDecodingScaleFactor(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn HAL_GetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn HAL_GetEncoderEncodingType(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> HAL_EncoderEncodingType;
}
extern "C" {
    pub fn HAL_Report(
        resource: i32,
        instanceNumber: i32,
        context: i32,
        feature: *const ::std::os::raw::c_char,
    ) -> i64;
}
pub const HAL_RuntimeType_HAL_Runtime_RoboRIO: HAL_RuntimeType = 0;
pub const HAL_RuntimeType_HAL_Runtime_RoboRIO2: HAL_RuntimeType = 1;
pub const HAL_RuntimeType_HAL_Runtime_Simulation: HAL_RuntimeType = 2;
pub type HAL_RuntimeType = i32;
extern "C" {
    pub fn HAL_GetLastError(status: *mut i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn HAL_GetErrorMessage(code: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn HAL_GetFPGAVersion(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetFPGARevision(status: *mut i32) -> i64;
}
extern "C" {
    pub fn HAL_GetSerialNumber(buffer: *mut ::std::os::raw::c_char, size: usize) -> usize;
}
extern "C" {
    pub fn HAL_GetComments(buffer: *mut ::std::os::raw::c_char, size: usize) -> usize;
}
extern "C" {
    pub fn HAL_GetRuntimeType() -> HAL_RuntimeType;
}
extern "C" {
    pub fn HAL_GetFPGAButton(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetSystemActive(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetBrownedOut(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetPort(channel: i32) -> HAL_PortHandle;
}
extern "C" {
    pub fn HAL_GetPortWithModule(module: i32, channel: i32) -> HAL_PortHandle;
}
extern "C" {
    pub fn HAL_GetFPGATime(status: *mut i32) -> u64;
}
extern "C" {
    pub fn HAL_ExpandFPGATime(unexpandedLower: u32, status: *mut i32) -> u64;
}
extern "C" {
    pub fn HAL_Initialize(timeout: i32, mode: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_Shutdown();
}
extern "C" {
    pub fn HAL_SimPeriodicBefore();
}
extern "C" {
    pub fn HAL_SimPeriodicAfter();
}
pub const HAL_I2CPort_HAL_I2C_kInvalid: HAL_I2CPort = -1;
pub const HAL_I2CPort_HAL_I2C_kOnboard: HAL_I2CPort = 0;
pub const HAL_I2CPort_HAL_I2C_kMXP: HAL_I2CPort = 1;
pub type HAL_I2CPort = i32;
extern "C" {
    pub fn HAL_InitializeI2C(port: HAL_I2CPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_TransactionI2C(
        port: HAL_I2CPort,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
        dataReceived: *mut u8,
        receiveSize: i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_WriteI2C(
        port: HAL_I2CPort,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_ReadI2C(port: HAL_I2CPort, deviceAddress: i32, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    pub fn HAL_CloseI2C(port: HAL_I2CPort);
}
extern "C" {
    pub fn HAL_InitializeInterrupts(status: *mut i32) -> HAL_InterruptHandle;
}
extern "C" {
    pub fn HAL_CleanInterrupts(interruptHandle: HAL_InterruptHandle);
}
extern "C" {
    pub fn HAL_WaitForInterrupt(
        interruptHandle: HAL_InterruptHandle,
        timeout: f64,
        ignorePrevious: HAL_Bool,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    pub fn HAL_WaitForMultipleInterrupts(
        interruptHandle: HAL_InterruptHandle,
        mask: i64,
        timeout: f64,
        ignorePrevious: HAL_Bool,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    pub fn HAL_ReadInterruptRisingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    pub fn HAL_ReadInterruptFallingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    pub fn HAL_RequestInterrupts(
        interruptHandle: HAL_InterruptHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetInterruptUpSourceEdge(
        interruptHandle: HAL_InterruptHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ReleaseWaitingInterrupt(interruptHandle: HAL_InterruptHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetMain(
        param: *mut ::std::os::raw::c_void,
        mainFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        exitFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    pub fn HAL_HasMain() -> HAL_Bool;
}
extern "C" {
    pub fn HAL_RunMain();
}
extern "C" {
    pub fn HAL_ExitMain();
}
extern "C" {
    pub fn HAL_InitializeNotifier(status: *mut i32) -> HAL_NotifierHandle;
}
extern "C" {
    pub fn HAL_SetNotifierThreadPriority(
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetNotifierName(
        notifierHandle: HAL_NotifierHandle,
        name: *const ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_StopNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_CleanNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_UpdateNotifierAlarm(
        notifierHandle: HAL_NotifierHandle,
        triggerTime: u64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_CancelNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_WaitForNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32) -> u64;
}
extern "C" {
    pub fn HAL_InitializePWMPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_DigitalHandle;
}
extern "C" {
    pub fn HAL_FreePWMPort(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_CheckPWMChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetPWMConfig(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: f64,
        deadbandMaxPwm: f64,
        centerPwm: f64,
        deadbandMinPwm: f64,
        minPwm: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetPWMConfigRaw(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: i32,
        deadbandMaxPwm: i32,
        centerPwm: i32,
        deadbandMinPwm: i32,
        minPwm: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetPWMConfigRaw(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: *mut i32,
        deadbandMaxPwm: *mut i32,
        centerPwm: *mut i32,
        deadbandMinPwm: *mut i32,
        minPwm: *mut i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        eliminateDeadband: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetPWMRaw(pwmPortHandle: HAL_DigitalHandle, value: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, speed: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMPosition(pwmPortHandle: HAL_DigitalHandle, position: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMDisabled(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetPWMRaw(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetPWMPosition(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_LatchPWMZero(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetPWMPeriodScale(
        pwmPortHandle: HAL_DigitalHandle,
        squelchMask: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetPWMLoopTiming(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetPWMCycleStartTime(status: *mut i32) -> u64;
}
extern "C" {
    pub fn HAL_GetNumAccumulators() -> i32;
}
extern "C" {
    pub fn HAL_GetNumAnalogTriggers() -> i32;
}
extern "C" {
    pub fn HAL_GetNumAnalogInputs() -> i32;
}
extern "C" {
    pub fn HAL_GetNumAnalogOutputs() -> i32;
}
extern "C" {
    pub fn HAL_GetNumCounters() -> i32;
}
extern "C" {
    pub fn HAL_GetNumDigitalHeaders() -> i32;
}
extern "C" {
    pub fn HAL_GetNumPWMHeaders() -> i32;
}
extern "C" {
    pub fn HAL_GetNumDigitalChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumPWMChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumDigitalPWMOutputs() -> i32;
}
extern "C" {
    pub fn HAL_GetNumEncoders() -> i32;
}
extern "C" {
    pub fn HAL_GetNumInterrupts() -> i32;
}
extern "C" {
    pub fn HAL_GetNumRelayChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumRelayHeaders() -> i32;
}
extern "C" {
    pub fn HAL_GetNumCTREPCMModules() -> i32;
}
extern "C" {
    pub fn HAL_GetNumCTRESolenoidChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumCTREPDPModules() -> i32;
}
extern "C" {
    pub fn HAL_GetNumCTREPDPChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumREVPDHModules() -> i32;
}
extern "C" {
    pub fn HAL_GetNumREVPDHChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumREVPHModules() -> i32;
}
extern "C" {
    pub fn HAL_GetNumREVPHChannels() -> i32;
}
extern "C" {
    pub fn HAL_GetNumDutyCycles() -> i32;
}
extern "C" {
    pub fn HAL_GetNumAddressableLEDs() -> i32;
}
extern "C" {
    pub fn HAL_GetVinVoltage(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetVinCurrent(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserVoltage6V(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserCurrent6V(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserActive6V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetUserCurrentFaults6V(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetUserVoltage5V(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserCurrent5V(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserActive5V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetUserCurrentFaults5V(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetUserVoltage3V3(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserCurrent3V3(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetUserActive3V3(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetUserCurrentFaults3V3(status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetBrownoutVoltage(status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_SetBrownoutVoltage(voltage: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_InitializeRelayPort(
        portHandle: HAL_PortHandle,
        fwd: HAL_Bool,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_RelayHandle;
}
extern "C" {
    pub fn HAL_FreeRelayPort(relayPortHandle: HAL_RelayHandle);
}
extern "C" {
    pub fn HAL_CheckRelayChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetRelay(relayPortHandle: HAL_RelayHandle, on: HAL_Bool, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetRelay(relayPortHandle: HAL_RelayHandle, status: *mut i32) -> HAL_Bool;
}
pub const HAL_SPIPort_HAL_SPI_kInvalid: HAL_SPIPort = -1;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS0: HAL_SPIPort = 0;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS1: HAL_SPIPort = 1;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS2: HAL_SPIPort = 2;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS3: HAL_SPIPort = 3;
pub const HAL_SPIPort_HAL_SPI_kMXP: HAL_SPIPort = 4;
pub type HAL_SPIPort = i32;
pub const HAL_SPIMode_HAL_SPI_kMode0: HAL_SPIMode = 0;
pub const HAL_SPIMode_HAL_SPI_kMode1: HAL_SPIMode = 1;
pub const HAL_SPIMode_HAL_SPI_kMode2: HAL_SPIMode = 2;
pub const HAL_SPIMode_HAL_SPI_kMode3: HAL_SPIMode = 3;
pub type HAL_SPIMode = i32;
extern "C" {
    pub fn HAL_InitializeSPI(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_TransactionSPI(
        port: HAL_SPIPort,
        dataToSend: *const u8,
        dataReceived: *mut u8,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_WriteSPI(port: HAL_SPIPort, dataToSend: *const u8, sendSize: i32) -> i32;
}
extern "C" {
    pub fn HAL_ReadSPI(port: HAL_SPIPort, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    pub fn HAL_CloseSPI(port: HAL_SPIPort);
}
extern "C" {
    pub fn HAL_SetSPISpeed(port: HAL_SPIPort, speed: i32);
}
extern "C" {
    pub fn HAL_SetSPIMode(port: HAL_SPIPort, mode: HAL_SPIMode);
}
extern "C" {
    pub fn HAL_GetSPIMode(port: HAL_SPIPort) -> HAL_SPIMode;
}
extern "C" {
    pub fn HAL_SetSPIChipSelectActiveHigh(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSPIChipSelectActiveLow(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetSPIHandle(port: HAL_SPIPort) -> i32;
}
extern "C" {
    pub fn HAL_SetSPIHandle(port: HAL_SPIPort, handle: i32);
}
extern "C" {
    pub fn HAL_InitSPIAuto(port: HAL_SPIPort, bufferSize: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_FreeSPIAuto(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_StartSPIAutoRate(port: HAL_SPIPort, period: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_StartSPIAutoTrigger(
        port: HAL_SPIPort,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        triggerRising: HAL_Bool,
        triggerFalling: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_StopSPIAuto(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSPIAutoTransmitData(
        port: HAL_SPIPort,
        dataToSend: *const u8,
        dataSize: i32,
        zeroSize: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ForceSPIAutoRead(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    pub fn HAL_ReadSPIAutoReceivedData(
        port: HAL_SPIPort,
        buffer: *mut u32,
        numToRead: i32,
        timeout: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_GetSPIAutoDroppedCount(port: HAL_SPIPort, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_ConfigureSPIAutoStall(
        port: HAL_SPIPort,
        csToSclkTicks: i32,
        stallTicks: i32,
        pow2BytesPerRead: i32,
        status: *mut i32,
    );
}
pub const HAL_SerialPort_HAL_SerialPort_Onboard: HAL_SerialPort = 0;
pub const HAL_SerialPort_HAL_SerialPort_MXP: HAL_SerialPort = 1;
pub const HAL_SerialPort_HAL_SerialPort_USB1: HAL_SerialPort = 2;
pub const HAL_SerialPort_HAL_SerialPort_USB2: HAL_SerialPort = 3;
pub type HAL_SerialPort = i32;
extern "C" {
    pub fn HAL_InitializeSerialPort(port: HAL_SerialPort, status: *mut i32)
        -> HAL_SerialPortHandle;
}
extern "C" {
    pub fn HAL_InitializeSerialPortDirect(
        port: HAL_SerialPort,
        portName: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_SerialPortHandle;
}
extern "C" {
    pub fn HAL_GetSerialFD(handle: HAL_SerialPortHandle, status: *mut i32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn HAL_SetSerialBaudRate(handle: HAL_SerialPortHandle, baud: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialDataBits(handle: HAL_SerialPortHandle, bits: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialParity(handle: HAL_SerialPortHandle, parity: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialStopBits(handle: HAL_SerialPortHandle, stopBits: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialWriteMode(handle: HAL_SerialPortHandle, mode: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialFlowControl(handle: HAL_SerialPortHandle, flow: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialTimeout(handle: HAL_SerialPortHandle, timeout: f64, status: *mut i32);
}
extern "C" {
    pub fn HAL_EnableSerialTermination(
        handle: HAL_SerialPortHandle,
        terminator: ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_DisableSerialTermination(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialReadBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetSerialWriteBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetSerialBytesReceived(handle: HAL_SerialPortHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_ReadSerial(
        handle: HAL_SerialPortHandle,
        buffer: *mut ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_WriteSerial(
        handle: HAL_SerialPortHandle,
        buffer: *const ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_FlushSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_ClearSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_CloseSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
pub const HAL_Type_HAL_UNASSIGNED: HAL_Type = 0;
pub const HAL_Type_HAL_BOOLEAN: HAL_Type = 1;
pub const HAL_Type_HAL_DOUBLE: HAL_Type = 2;
pub const HAL_Type_HAL_ENUM: HAL_Type = 4;
pub const HAL_Type_HAL_INT: HAL_Type = 8;
pub const HAL_Type_HAL_LONG: HAL_Type = 16;
pub type HAL_Type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HAL_Value {
    pub data: HAL_Value__bindgen_ty_1,
    pub type_: HAL_Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HAL_Value__bindgen_ty_1 {
    pub v_boolean: HAL_Bool,
    pub v_enum: i32,
    pub v_int: i32,
    pub v_long: i64,
    pub v_double: f64,
}
#[test]
fn bindgen_test_layout_HAL_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_enum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_enum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_long) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
}
#[test]
fn bindgen_test_layout_HAL_Value() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_Value>(),
        16usize,
        concat!("Size of: ", stringify!(HAL_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(type_)
        )
    );
}
pub const HAL_SimValueDirection_HAL_SimValueInput: HAL_SimValueDirection = 0;
pub const HAL_SimValueDirection_HAL_SimValueOutput: HAL_SimValueDirection = 1;
pub const HAL_SimValueDirection_HAL_SimValueBidir: HAL_SimValueDirection = 2;
pub type HAL_SimValueDirection = i32;
extern "C" {
    pub fn HAL_CreateSimDevice(name: *const ::std::os::raw::c_char) -> HAL_SimDeviceHandle;
}
extern "C" {
    pub fn HAL_FreeSimDevice(handle: HAL_SimDeviceHandle);
}
extern "C" {
    pub fn HAL_GetSimDeviceName(handle: HAL_SimDeviceHandle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn HAL_CreateSimValue(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        initialValue: *const HAL_Value,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    pub fn HAL_CreateSimValueEnum(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        numOptions: i32,
        options: *mut *const ::std::os::raw::c_char,
        initialValue: i32,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    pub fn HAL_CreateSimValueEnumDouble(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        numOptions: i32,
        options: *mut *const ::std::os::raw::c_char,
        optionValues: *const f64,
        initialValue: i32,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    pub fn HAL_GetSimValue(handle: HAL_SimValueHandle, value: *mut HAL_Value);
}
extern "C" {
    pub fn HAL_SetSimValue(handle: HAL_SimValueHandle, value: *const HAL_Value);
}
extern "C" {
    pub fn HAL_ResetSimValue(handle: HAL_SimValueHandle);
}
pub type NativeThreadHandle = *const ::std::os::raw::c_void;
extern "C" {
    pub fn HAL_GetThreadPriority(
        handle: NativeThreadHandle,
        isRealTime: *mut HAL_Bool,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    pub fn HAL_GetCurrentThreadPriority(isRealTime: *mut HAL_Bool, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetThreadPriority(
        handle: NativeThreadHandle,
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetCurrentThreadPriority(
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
pub const HAL_REVPHCompressorConfigType_HAL_REVPHCompressorConfigType_kDisabled:
    HAL_REVPHCompressorConfigType = 0;
pub const HAL_REVPHCompressorConfigType_HAL_REVPHCompressorConfigType_kDigital:
    HAL_REVPHCompressorConfigType = 1;
pub const HAL_REVPHCompressorConfigType_HAL_REVPHCompressorConfigType_kAnalog:
    HAL_REVPHCompressorConfigType = 2;
pub const HAL_REVPHCompressorConfigType_HAL_REVPHCompressorConfigType_kHybrid:
    HAL_REVPHCompressorConfigType = 3;
pub type HAL_REVPHCompressorConfigType = i32;
#[doc = " Storage for REV PH Version"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_REVPHVersion {
    pub firmwareMajor: u32,
    pub firmwareMinor: u32,
    pub firmwareFix: u32,
    pub hardwareMinor: u32,
    pub hardwareMajor: u32,
    pub uniqueId: u32,
}
#[test]
fn bindgen_test_layout_HAL_REVPHVersion() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_REVPHVersion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_REVPHVersion>(),
        24usize,
        concat!("Size of: ", stringify!(HAL_REVPHVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_REVPHVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_REVPHVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareMajor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(firmwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareMinor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(firmwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareFix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(firmwareFix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardwareMinor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(hardwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardwareMajor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(hardwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uniqueId) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(uniqueId)
        )
    );
}
#[doc = " Storage for compressor config"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_REVPHCompressorConfig {
    pub minAnalogVoltage: f64,
    pub maxAnalogVoltage: f64,
    pub forceDisable: HAL_Bool,
    pub useDigital: HAL_Bool,
}
#[test]
fn bindgen_test_layout_HAL_REVPHCompressorConfig() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_REVPHCompressorConfig> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_REVPHCompressorConfig>(),
        24usize,
        concat!("Size of: ", stringify!(HAL_REVPHCompressorConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_REVPHCompressorConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_REVPHCompressorConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minAnalogVoltage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHCompressorConfig),
            "::",
            stringify!(minAnalogVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxAnalogVoltage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHCompressorConfig),
            "::",
            stringify!(maxAnalogVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forceDisable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHCompressorConfig),
            "::",
            stringify!(forceDisable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useDigital) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHCompressorConfig),
            "::",
            stringify!(useDigital)
        )
    );
}
#[doc = " Storage for REV PH Faults"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HAL_REVPHFaults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_HAL_REVPHFaults() {
    assert_eq!(
        ::std::mem::size_of::<HAL_REVPHFaults>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_REVPHFaults))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_REVPHFaults>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_REVPHFaults))
    );
}
impl HAL_REVPHFaults {
    #[inline]
    pub fn channel0Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel0Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel1Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel1Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel2Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel2Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel3Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel3Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel4Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel4Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel5Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel5Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel6Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel6Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel7Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel7Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel8Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel8Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel9Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel9Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel10Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel10Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel11Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel11Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel12Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel12Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel13Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel13Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel14Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel14Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel15Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel15Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compressorOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compressorOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compressorOpen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compressorOpen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn solenoidOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_solenoidOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_canWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hardwareFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hardwareFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        channel0Fault: u32,
        channel1Fault: u32,
        channel2Fault: u32,
        channel3Fault: u32,
        channel4Fault: u32,
        channel5Fault: u32,
        channel6Fault: u32,
        channel7Fault: u32,
        channel8Fault: u32,
        channel9Fault: u32,
        channel10Fault: u32,
        channel11Fault: u32,
        channel12Fault: u32,
        channel13Fault: u32,
        channel14Fault: u32,
        channel15Fault: u32,
        compressorOverCurrent: u32,
        compressorOpen: u32,
        solenoidOverCurrent: u32,
        brownout: u32,
        canWarning: u32,
        hardwareFault: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let channel0Fault: u32 = unsafe { ::std::mem::transmute(channel0Fault) };
            channel0Fault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let channel1Fault: u32 = unsafe { ::std::mem::transmute(channel1Fault) };
            channel1Fault as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let channel2Fault: u32 = unsafe { ::std::mem::transmute(channel2Fault) };
            channel2Fault as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let channel3Fault: u32 = unsafe { ::std::mem::transmute(channel3Fault) };
            channel3Fault as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let channel4Fault: u32 = unsafe { ::std::mem::transmute(channel4Fault) };
            channel4Fault as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let channel5Fault: u32 = unsafe { ::std::mem::transmute(channel5Fault) };
            channel5Fault as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let channel6Fault: u32 = unsafe { ::std::mem::transmute(channel6Fault) };
            channel6Fault as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let channel7Fault: u32 = unsafe { ::std::mem::transmute(channel7Fault) };
            channel7Fault as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let channel8Fault: u32 = unsafe { ::std::mem::transmute(channel8Fault) };
            channel8Fault as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let channel9Fault: u32 = unsafe { ::std::mem::transmute(channel9Fault) };
            channel9Fault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let channel10Fault: u32 = unsafe { ::std::mem::transmute(channel10Fault) };
            channel10Fault as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let channel11Fault: u32 = unsafe { ::std::mem::transmute(channel11Fault) };
            channel11Fault as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let channel12Fault: u32 = unsafe { ::std::mem::transmute(channel12Fault) };
            channel12Fault as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let channel13Fault: u32 = unsafe { ::std::mem::transmute(channel13Fault) };
            channel13Fault as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let channel14Fault: u32 = unsafe { ::std::mem::transmute(channel14Fault) };
            channel14Fault as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let channel15Fault: u32 = unsafe { ::std::mem::transmute(channel15Fault) };
            channel15Fault as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let compressorOverCurrent: u32 =
                unsafe { ::std::mem::transmute(compressorOverCurrent) };
            compressorOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let compressorOpen: u32 = unsafe { ::std::mem::transmute(compressorOpen) };
            compressorOpen as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let solenoidOverCurrent: u32 = unsafe { ::std::mem::transmute(solenoidOverCurrent) };
            solenoidOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let brownout: u32 = unsafe { ::std::mem::transmute(brownout) };
            brownout as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let canWarning: u32 = unsafe { ::std::mem::transmute(canWarning) };
            canWarning as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let hardwareFault: u32 = unsafe { ::std::mem::transmute(hardwareFault) };
            hardwareFault as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Storage for REV PH Sticky Faults"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HAL_REVPHStickyFaults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_HAL_REVPHStickyFaults() {
    assert_eq!(
        ::std::mem::size_of::<HAL_REVPHStickyFaults>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_REVPHStickyFaults))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_REVPHStickyFaults>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_REVPHStickyFaults))
    );
}
impl HAL_REVPHStickyFaults {
    #[inline]
    pub fn compressorOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compressorOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compressorOpen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compressorOpen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn solenoidOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_solenoidOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_canWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canBusOff(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_canBusOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasReset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasReset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compressorOverCurrent: u32,
        compressorOpen: u32,
        solenoidOverCurrent: u32,
        brownout: u32,
        canWarning: u32,
        canBusOff: u32,
        hasReset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compressorOverCurrent: u32 =
                unsafe { ::std::mem::transmute(compressorOverCurrent) };
            compressorOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let compressorOpen: u32 = unsafe { ::std::mem::transmute(compressorOpen) };
            compressorOpen as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let solenoidOverCurrent: u32 = unsafe { ::std::mem::transmute(solenoidOverCurrent) };
            solenoidOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let brownout: u32 = unsafe { ::std::mem::transmute(brownout) };
            brownout as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let canWarning: u32 = unsafe { ::std::mem::transmute(canWarning) };
            canWarning as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let canBusOff: u32 = unsafe { ::std::mem::transmute(canBusOff) };
            canBusOff as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasReset: u32 = unsafe { ::std::mem::transmute(hasReset) };
            hasReset as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn HAL_InitializeREVPH(
        module: i32,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_REVPHHandle;
}
extern "C" {
    pub fn HAL_FreeREVPH(handle: HAL_REVPHHandle);
}
extern "C" {
    pub fn HAL_CheckREVPHSolenoidChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_CheckREVPHModuleNumber(module: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetREVPHCompressor(handle: HAL_REVPHHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetREVPHCompressorConfig(
        handle: HAL_REVPHHandle,
        config: *const HAL_REVPHCompressorConfig,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetREVPHClosedLoopControlDisabled(handle: HAL_REVPHHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetREVPHClosedLoopControlDigital(handle: HAL_REVPHHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetREVPHClosedLoopControlAnalog(
        handle: HAL_REVPHHandle,
        minAnalogVoltage: f64,
        maxAnalogVoltage: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetREVPHClosedLoopControlHybrid(
        handle: HAL_REVPHHandle,
        minAnalogVoltage: f64,
        maxAnalogVoltage: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetREVPHCompressorConfig(
        handle: HAL_REVPHHandle,
        status: *mut i32,
    ) -> HAL_REVPHCompressorConfigType;
}
extern "C" {
    pub fn HAL_GetREVPHPressureSwitch(handle: HAL_REVPHHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetREVPHCompressorCurrent(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHAnalogVoltage(
        handle: HAL_REVPHHandle,
        channel: i32,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHVoltage(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPH5VVoltage(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHSolenoidCurrent(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHSolenoidVoltage(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHVersion(
        handle: HAL_REVPHHandle,
        version: *mut HAL_REVPHVersion,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetREVPHSolenoids(handle: HAL_REVPHHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetREVPHSolenoids(handle: HAL_REVPHHandle, mask: i32, values: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_FireREVPHOneShot(handle: HAL_REVPHHandle, index: i32, durMs: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetREVPHFaults(
        handle: HAL_REVPHHandle,
        faults: *mut HAL_REVPHFaults,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetREVPHStickyFaults(
        handle: HAL_REVPHHandle,
        stickyFaults: *mut HAL_REVPHStickyFaults,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ClearREVPHStickyFaults(handle: HAL_REVPHHandle, status: *mut i32);
}
